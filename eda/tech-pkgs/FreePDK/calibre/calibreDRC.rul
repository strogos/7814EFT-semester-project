////////////////////////////////////////////////////////////////////////////////////
///////////////////////     14nm Free PDK  Rules SVRF    ///////////////////////////
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//__________________________________________________ Define Specification Statements 
////////////////////////////////////////////////////////////////////////////////////
//__________________________________________________________________________________
LAYOUT SYSTEM 			GDSII
LAYOUT PATH 			"./test.gds"
LAYOUT PRIMARY 			TOPCELL
DRC SUMMARY REPORT 		drc_report
DRC RESULTS DATABASE 		drc_results.db
DRC INCREMENTAL CONNECT YES

PRECISION			5000
LAYOUT PRECISION 		1000
LAYOUT MAGNIFY			AUTO
RESOLUTION			1
//XXX changed resolution from 500 to 1 to get rid of grid errors 
////////////////////////////////////////////////////////////////////////////////////
//___________________________________________________________ Define Original Layers
////////////////////////////////////////////////////////////////////////////////////
// NOTE	:	layer numbers are assumed here, but it must match layer numbers
//		at the layout's GDS file.
//__________________________________________________________________________________
layer	NW	0	//	N-Well
layer	ACT	1	//	Active area for fin definition
layer	VTH	2	//	High Threshold adjust mask
layer	VTL	3	//	Low Threshold adjust mask
layer	THKOX	4	//	Thick-Oxide adjust mask
layer	NIM	5	//	N-implant
layer	PIM	6	//	P-implant
layer	GATEA	7	//	Gate metal, Color A
layer	GATEB	8	//	Gate metal, Color B
layer	GATEC	9	//	Gate metal Cut
layer   GATEAB  10 	//  	whole gate metal (without double patterning assuming coloring is done later)
layer	AIL1	11	//	Active Interconnect Layer, level 1
layer	AIL2	12	//	Active Interconnect Layer, level 2
layer	GIL	13	//	Gate Interconnect Layer
layer	V0	14	//	Via Zero, connecting to first level of interconnect metal
layer	M1A	15	//	First Level of Interconnect Metal, Color A
layer	M1B	16	//	First Level of Interconnect Metal, Color B
layer	V1	17	//	Via connecting M1 to next higher level of metal MINT1
layer	MINT1A	18	//	Intermediate metal, Color A, n=1
layer	MINT2A	19	//	Intermediate metal, Color A, n=2
layer	MINT3A	20	//	Intermediate metal, Color A, n=3
layer	MINT4A	21	//	Intermediate metal, Color A, n=4
layer	MINT5A	22	//	Intermediate metal, Color A, n=5
layer	MINT1B	23	//	Intermediate metal, Color B, n=1
layer	MINT2B	24	//	Intermediate metal, Color B, n=2
layer	MINT3B	25	//	Intermediate metal, Color B, n=3
layer	MINT4B	26	//	Intermediate metal, Color B, n=4
layer	MINT5B	27	//	Intermediate metal, Color B, n=5
layer	V2	28	//	Via connecting MINT1 to next higher level of metal MINT2
layer	V3	29	//	Via connecting MINT2 to next higher level of metal MINT3
layer	V4	30	//	Via connecting MINT3 to next higher level of metal MINT4
layer	V5	31	//	Via connecting MINT4 to next higher level of metal MINT5
layer	MSMG1	32	//	Semi-global metal, n=1
layer	MSMG2	33	//	Semi-global metal, n=2
layer	MSMG3	34	//	Semi-global metal, n=3
layer	MSMG4	35	//	Semi-global metal, n=4
layer	MSMG5	36	//	Semi-global metal, n=5
layer	VSMG1	37	//	Via connecting MSMG1 to next higher level of metal MSMG2
layer	VSMG2	38	//	Via connecting MSMG2 to next higher level of metal MSMG3
layer	VSMG3	39	//	Via connecting MSMG3 to next higher level of metal MSMG4
layer	VSMG4	40	//	Via connecting MSMG4 to next higher level of metal MSMG5
layer	VSMG5	41	//	Via connecting MSMG5 to next higher level of metal MSMG6
layer	MG1	42	//	Global metal, n=1
layer	MG2	43	//	Global metal, n=2
layer	VG1	44	//	Via connecting MG1 to next higher level of metal MG2
layer	RECTV0	45	//	Rectangular Vias
layer	RECTV1	46	//	Rectangular Vias //XXX RECTn changed to RECTV1
layer	NCONT	47	//	Rectangular Vias
layer   V6 	48	// 	Via connecting MINT5 to next higher level of metal MSMG1
layer  prBoundary 200 //
///XXX Via layers added for contact between semi global and intermediate layers

/*======================================================================================== 

THE FOLLOWING CONNECTIVITY IS PRESUMED "RELATED TO LAYERS STATED RULES"

____________________________________ ______________________________________________________________________________________________________ MG2
                                    |
                                    |VG1
____________________________________|______ _______________________________________________________________________________________________ MG1
					   |
 					   |VSMG5
___________________________________________|_______ _______________________________________________________________________________________ MSMG5
						   |
						   |VSMG4
___________________________________________________|_______ _______________________________________________________________________________ MSMG4
							   |
							   |VSMG3
___________________________________________________________|_______ _______________________________________________________________________ MSMG3
                                                                   |
                                                                   |VSMG2
___________________________________________________________________|______ ________________________________________________________________ MSMG2
                                                                          |
                                                                          |VSMG1
__________________________________________________________________________|______ _________________________________________________________ MSMG1
                                                                                 |
									         |V6
_________________________________________________________________________________|_____ ___________________________________________________ MINT5[A|B]
		                                                                       |
		                                                                       | V5
_______________________________________________________________________________________|_______ ___________________________________________ MINT4[A|B]
			                                                                       |
			                                                                       | V4
_______________________________________________________________________________________________|_______ ___________________________________ MINT3[A|B]
				                                                                       |
				                                                                       | V3
_______________________________________________________________________________________________________|_______ ___________________________ MINT2[A|B]
					                                                                       |
			                                                                                       | V2
_______________________________________________________________________________________________________________|_______ ___________________ MINT1[A|B]
						                                                                       |
						                                                                       | V1
_______________________________________________________________________________________________________________________|_______ ____________ M1[A|B]
							                                                                       |
				   			        						               | V0
______ ______ _______ _______ ______ ______ ______ _______ _______ ______ ______ _______ _______ _______ _______ _______ ______|____________ GIL|AIL2
______|______|______|_______|_______|______|______|_______|_______|______|______|_______|_______|_______|_______|_______|______|____________ GATE[A|B]


===========================================================================================*/

///////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________ Define Derived Boolean Layers
///////////////////////////////////////////////////////////////////////////////////////
PW 		= (EXTENTS NW) NOT NW 	// P-Well assumed to be where NW is not found
CHANNEL_A       = GATEA AND ACT
CHANNEL_B	= GATEB AND ACT
CHANNEL_AB	= GATEAB AND ACT

N_GATE_A	= CHANNEL_A AND NIM	// N Gates at pattern "Color" A
P_GATE_A	= CHANNEL_A AND PIM	// P Gates at pattern "Color" A
N_GATE_B	= CHANNEL_B AND NIM	// N Gates at pattern "Color" B
P_GATE_B	= CHANNEL_B AND PIM	// P Gates at pattern "Color" B
N_GATE_AB	= CHANNEL_AB AND NIM	// N Gates at pattern "Color" AB
P_GATE_AB	= CHANNEL_AB AND PIM	// P Gates at pattern "Color" AB

//XXX Extra terms added for NIM3A/PIM3A/NIM3B/PIM3B
N_EXT_N_GATE_A  = NIM NOT N_GATE_A 
P_EXT_P_GATE_A  = PIM NOT P_GATE_A
N_EXT_N_GATE_B  = NIM NOT N_GATE_B
P_EXT_P_GATE_B  = PIM NOT P_GATE_B 
N_EXT_N_GATE_AB = NIM NOT N_GATE_AB 
P_EXT_P_GATE_AB = PIM NOT P_GATE_AB

//XXX AIL1 and AIL2 overlap for rule AIL2.5
AIL_OVERLAP     = AIL1 AND AIL2

N_SD_A		= NIM NOT CHANNEL_A	// N SD for GATE A
P_SD_A		= PIM NOT CHANNEL_A	// P SD for GATE A
N_SD_B		= NIM NOT CHANNEL_B	// N SD for GATE B
P_SD_B		= PIM NOT CHANNEL_B	// P SD for GATE B
N_SD_AB		= NIM NOT CHANNEL_AB	// N SD for GATE AB
P_SD_AB		= PIM NOT CHANNEL_AB	// P SD for GATE AB

// Create a layer called NW_MAG that is a scaled copy of NW.
// Specific for NW layer rule checks.
NW_MAG 		= MAGNIFY NW BY 0.8 
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________ Define Nets Connections
////////////////////////////////////////////////////////////////////////////////////

 CONNECT NCONT NW
 CONNECT NCONT NW_MAG
 CONNECT GATEA GIL
 CONNECT N_GATE_A GIL
 CONNECT P_GATE_A GIL
 CONNECT M1A GIL BY V0
 CONNECT MINT1A M1A BY V1
 CONNECT MINT2A MINT1A BY V2
 CONNECT MINT3A MINT2A BY V3
 CONNECT MINT4A MINT3A BY V4
 CONNECT MINT5A MINT4A BY V5
 CONNECT GATEB GIL
 CONNECT N_GATE_B GIL
 CONNECT P_GATE_B GIL
 CONNECT M1B GIL BY V0
 CONNECT MINT1B M1B BY V1
 CONNECT MINT2B MINT1B BY V2
 CONNECT MINT3B MINT2B BY V3
 CONNECT MINT4B MINT3B BY V4
 CONNECT MINT5B MINT4B BY V5
 CONNECT AIL2 M1A BY V0
 CONNECT AIL2 M1B BY V0
 CONNECT AIL1 AIL2
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________Technology Definitions and Considerations
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________NW LAYER RULES
////////////////////////////////////////////////////////////////////////////////////


RULE_NW001{
 @ RULE_NW001
 @ Minimum spacing of NW (or) PW at different potential is 180nm
 @ Scale ratio of 0.8
 EXTERNAL NW_MAG < 0.180 NOT CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW002{
 @ RULE_NW002
 @ Minimum spacing of NW (or) PW at same potential is 110nm
 @ Scale ratio of 0.8
 EXTERNAL NW_MAG < 0.110 CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW003{
 @ RULE_NW003
 @ Minimum width of NW is 160nm
 @ Scale ratio of 0.8
 INTERNAL NW_MAG < 0.160 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW004A{
 @ RULE_NW004A
 @ Minimum area of NW is 0.140 um2
 AREA NW  < 0.140 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW004B{
 @ RULE_NW004B
 @ Minimum enclosed area of NW is 0.140 um2
 HOLES NW < 0.140
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW005{
 @ RULE_NW005
 @ NW Must be orthogonal
 ANGLE NW >0 <90
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW006A{
 @ RULE_NW006A
 @ Minimum extension of NW past CHANNEL_A is 80nm
 CHANNEL_A_VERTICAL_EDGES = CHANNEL_A ANGLE == 90
 NW_VERTICAL_EDGES = NW ANGLE == 90
 INTERNAL NW_VERTICAL_EDGES CHANNEL_A_VERTICAL_EDGES < 0.080 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NW006B{
 @ RULE_NW006B
 @ Minimum extension of NW past CHANNEL_B is 80nm
 CHANNEL_B_VERTICAL_EDGES = CHANNEL_B ANGLE == 90
 NW_VERTICAL_EDGES = NW ANGLE == 90
 INTERNAL NW_VERTICAL_EDGES CHANNEL_B_VERTICAL_EDGES < 0.080 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_NW006AB{
 @ RULE_NW006AB
 @ Minimum extension of NW past CHANNEL_AB is 80nm
 CHANNEL_AB_VERTICAL_EDGES = CHANNEL_AB ANGLE == 90
 NW_VERTICAL_EDGES = NW ANGLE == 90
 INTERNAL NW_VERTICAL_EDGES CHANNEL_AB_VERTICAL_EDGES < 0.080 
}
////////////////////////////////////////////////////////////////////////////////////
//_______________________________________________________________ ACTIVE LAYER RULES
////////////////////////////////////////////////////////////////////////////////////

RULE_ACT001{
 @ RULE_ACT001
 @ Minimum vertical width of ACT layer is 48nm
 ACT_HORIZONTAL_EDGES = ACT ANGLE == 0
 INTERNAL ACT_HORIZONTAL_EDGES < 0.048 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT002{
 @ RULE_ACT002
 @ Minimum Incremental vertical width of ACT layer is 40nm
 ACT_HORIZONTAL_EDGES = ACT ANGLE == 0
 //INC1_WIDTH = WITH WIDTH ACT != 0.040
 //INC2_WIDTH = WITH WIDTH ACT != 0.080
 //INC3_WIDTH = WITH WIDTH ACT != 0.120
 //OR (OR INC1_WIDTH INC2_WIDTH) INC3_WIDTH
  INTERNAL ACT_HORIZONTAL_EDGES < 0.048
  INTERNAL ACT_HORIZONTAL_EDGES > 0.048 < 0.088 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.088 < 0.128 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.128 < 0.168
  INTERNAL ACT_HORIZONTAL_EDGES > 0.168 < 0.208
  INTERNAL ACT_HORIZONTAL_EDGES > 0.208 < 0.248
  INTERNAL ACT_HORIZONTAL_EDGES > 0.248 < 0.288
  INTERNAL ACT_HORIZONTAL_EDGES > 0.288 < 0.328
  INTERNAL ACT_HORIZONTAL_EDGES > 0.328 < 0.368
  INTERNAL ACT_HORIZONTAL_EDGES > 0.368 < 0.408
  INTERNAL ACT_HORIZONTAL_EDGES > 0.408 < 0.448
  INTERNAL ACT_HORIZONTAL_EDGES > 0.448 < 0.488
  INTERNAL ACT_HORIZONTAL_EDGES > 0.488 < 0.528 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.528 < 0.568
  INTERNAL ACT_HORIZONTAL_EDGES > 0.568 < 0.608
  INTERNAL ACT_HORIZONTAL_EDGES > 0.608 < 0.648
  INTERNAL ACT_HORIZONTAL_EDGES > 0.648 < 0.688 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.688 < 0.728 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.728 < 0.768
  INTERNAL ACT_HORIZONTAL_EDGES > 0.768 < 0.808
  INTERNAL ACT_HORIZONTAL_EDGES > 0.808 < 0.848
  INTERNAL ACT_HORIZONTAL_EDGES > 0.848 < 0.888 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.888 < 0.928 
  INTERNAL ACT_HORIZONTAL_EDGES > 0.928 < 0.968
  INTERNAL ACT_HORIZONTAL_EDGES > 0.968 < 1.008
}
///XXX 
//INC1_WIDTH = WITH WIDTH ACT != 0.040
//INC2_WIDTH = WITH WIDTH ACT != 0.080
//INC3_WIDTH = WITH WIDTH ACT != 0.120
//OR (OR INC1_WIDTH INC2_WIDTH) INC3_WIDTH
// changed to  INTERNAL ACT_HORIZONTAL_EDGES < 0.048
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.048 < 0.088 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.088 < 0.128 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.128 < 0.168
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.168 < 0.208
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.208 < 0.248
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.248 < 0.288
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.288 < 0.328
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.328 < 0.368
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.368 < 0.408
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.408 < 0.448
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.448 < 0.488
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.488 < 0.528 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.528 < 0.568
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.568 < 0.608
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.608 < 0.648
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.648 < 0.688 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.688 < 0.728 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.728 < 0.768
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.768 < 0.808
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.808 < 0.848
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.848 < 0.888 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.888 < 0.928 
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.928 < 0.968
//  INTERNAL ACT_HORIZONTAL_EDGES > 0.968 < 1.008
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT003{
 @ RULE_ACT003
 @ Minimum vertical spacing of ACT is 62nm
 ACT_HORIZONTAL_EDGES = ACT ANGLE == 0
 EXTERNAL ACT_HORIZONTAL_EDGES < 0.062
}
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT004{
 @ RULE_ACT004
 @ Minimum horizontal width of ACT is 96nm
 ACT_VERTICAL_EDGES = ACT ANGLE == 90
 INTERNAL ACT_VERTICAL_EDGES < 0.096
}
///XXX Angle changed to 90 from 0
///XXX changed width to 112nm from 160nm
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT005{ 
 @ RULE_ACT005
 @ Horizontal spacing of ACT  must be exactly 32nm
 ACT_VERTICAL_EDGES = ACT ANGLE == 90
 EXTERNAL ACT_VERTICAL_EDGES > 0 < 0.032 OPPOSITE 
 EXTERNAL ACT_VERTICAL_EDGES > 0.032 < 0.16 OPPOSITE
}
//XXX Changed the angle to 90 from 0
//XXX EXTERNAL ACT_VERTICAL_EDGES > 0 < 0.032  
///   EXTERNAL ACT_VERTICAL_EDGES > 0.032 < 1 
// changed to EXTERNAL ACT_VERTICAL_EDGES > 0 < 0.080 OPPOSITE 
// EXTERNAL ACT_VERTICAL_EDGES > 0.080 < 0.24 OPPOSITE
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT006{
 @ RULE_ACT006
 @ Minimum notch of ACT is 112nm
 EXTERNAL ACT < 0.112 NOTCH
}
// XXX EXTERNAL ACT < 0.160 NOTCH
// changed to EXTERNAL ACT < 0.112 NOTCH
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT007A{
 @ RULE_ACT007A
 @ Minimum spacing of NW to ACT is 31nm
 EXTERNAL NW ACT < 0.031
}
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT007B{
 @ RULE_ACT007B
 @ Minimum enclosure of NW to ACT is 31nm
 ENCLOSURE NW ACT < 0.031
}
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT008A{
 @ RULE_ACT008A
 @ Minimum area of ACT is 0.005000 um2
 AREA ACT  < 0.005000
} 
// XXX  AREA ACT  < 0.006460
// changed to AREA ACT  < 0.005000
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT008B{
 @ RULE_ACT008B
 @ Minimum enclosed area of ACT is 0.005000 um2
 HOLES ACT < 0.005000
}
// XXX HOLES ACT < 0.006460
// changed to  HOLES ACT < 0.006460
////////////////////////////////////////////////////////////////////////////////////
RULE_ACT009{
 @ RULE_ACT009
 @ Maximum distance between ACT forming a MOS device and ACT forming a bulk/substrate
 @ contact within the same well/substrate is 30um, to prevent latch up
 // 1 - Create derived layers for ACT forming MOS device (Double Patterns)
 ACT_MOS_SD_A = GATEA NOT ACT
 ACT_MOS_SD_B = GATEB NOT ACT

 // 2 - Create derived layers for ACT forming a bulk/substrate contact
 ACT_CONTACT_L1 = AIL1 AND ACT
 ACT_CONTACT_L2 = AIL2 AND ACT
 // 3 - Apply the spacing rule on the combination of the derived layers
a = ACT_CONTACT_L1 SIZE BY 30
ACT_MOS_SD_A NOT INSIDE a
ACT_MOS_SD_B NOT INSIDE a
b = ACT_CONTACT_L2 SIZE BY 30
ACT_MOS_SD_A NOT INSIDE b
ACT_MOS_SD_B NOT INSIDE b
}

////////////////////////////////////////////////////////////////////////////////////
//___________________________________GATE LAYER (Double Patterning - 2 colors) RULES
////////////////////////////////////////////////////////////////////////////////////

GATEA_vertical_edges = GATEA ANGLE ==90
GATEA_horizontal_edges = GATEA ANGLE ==0
GATEB_vertical_edges = GATEB ANGLE ==90
GATEB_horizonatl_edges = GATEB ANGLE ==0

RULE_GATE001A{
 @ RULE_GATE001A
 @ Exact horizontal width of GATE [A] is 20, 16 or 14 nm
 INTERNAL GATEA_vertical_edges < 0.014 
 INTERNAL GATEA_vertical_edges > 0.014 < 0.016
 INTERNAL GATEA_vertical_edges > 0.016 < 0.020
 INTERNAL GATEA_vertical_edges > 0.020 < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE001B{
 @ RULE_GATE001B
 @ Exact horizontal width of GATE [B] is 20, 16 or 14 nm
 INTERNAL GATEB_vertical_edges < 0.014 
 INTERNAL GATEB_vertical_edges > 0.014 < 0.016
 INTERNAL GATEB_vertical_edges > 0.016 < 0.020
 INTERNAL GATEB_vertical_edges > 0.020 < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE002A{
 @ RULE_GATE002A
 @ Min horizontal pitch of GATE [A] is 128 nm 
 //select vertical edge pairs on same polygons, constraint is 1 to include all edge pairs
 x = INT GATEA_vertical_edges < 1
 //derive centerlines between edge pairs
 y = DFM COPY x CENTERLINE
 //expand the centerlines by a very small value to form very thin polygons
 y_copy = EXPAND EDGE y INSIDE BY 0.001
 y_copy_vertical_edge =  y_copy ANGLE ==90
 //output gate polygons that have a horizontal pitch less than 128nm
 EXT y_copy_vertical_edge < 0.127 OPPOSITE
}
///XXX EXT y_copy < 0.128 OPPOSITE
///changed to EXT y_copy < 0.127 OPPOSITE. This was done to solve the issue of GATE002A error when the pitch was exactly 128nm. 
//This issue appeared because of the expand centreline statement. The centreline was expanded in order to draw thin polygons. 
//Making the separation 127nm solves the problem of 1nm expansion introduced by the expand statement 
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE002B{
 @ RULE_GATE002B
 @ Min horizontal pitch of GATE [B] is 128 nm 
 //select vertical edge pairs on same polygons, constraint is 1 to include all edge pairs
 x = INT GATEB_vertical_edges < 1
 //derive centerlines between edge pairs
 y = DFM COPY x CENTERLINE
 //expand the centerlines by a very small value to form very thin polygons
 y_copy = EXPAND EDGE y INSIDE BY 0.001
 y_copy_vertical_edge =  y_copy ANGLE ==90
 //output gate polygons that have a horizontal pitch less than 128nm
 EXT y_copy_vertical_edge < 0.127 OPPOSITE 
}
///XXX EXT y_copy < 0.128 OPPOSITE
///changed to EXT y_copy < 0.127 OPPOSITE. This was done to solve the issue of GATE002B error when the pitch was exactly 128nm. 
//This issue appeared because of the expand centreline statement. The centreline was expanded in order to draw thin polygons. 
//Making the separation 127nm solves the problem of 1nm expansion introduced by the expand statement 
//XXX y_copy = EXPAND EDGE y INSIDE BY 0.001
//    output gate polygons that have a horizontal pitch less than 128nm
//    EXT y_copy < 0.127 OPPOSITE 
// Changed to y_copy = EXPAND EDGE y INSIDE BY 0.001
// 	      y_copy_vertical_edge =  y_copy ANGLE ==90
// 	      EXT y_copy_vertical_edge < 0.127 OPPOSITE 
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE003{
 @ RULE_GATE003
 @ Minimum horizontal spacing of GATE[A] and GATE[B] is 44 nm
 EXTERNAL GATEA_vertical_edges GATEB_vertical_edges < 0.044
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE004A{
 @ RULE_GATE004A
 @ GATE[A] may not bend
 CONVEX EDGE GATEA ANGLE1 > 90 ANGLE2 > 0 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE004B{
 @ RULE_GATE004B
 @ GATE[B] may not bend
 CONVEX EDGE GATEB ANGLE1 > 90 ANGLE2 > 0 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE005A{
 @ RULE_GATE005A
 @ Minimum extension of ACT past GATE [A] is 38nm
 ENCLOSURE GATEA ACT < 0.038
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE005B{
 @ RULE_GATE005B
 @ Minimum extension of ACT past GATE [B] is 38nm
 ENCLOSURE GATEB ACT < 0.038
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE006A{
 @ RULE_GATE006A
 @ Minimum extension of GATE [A] past ACT is 62nm
 ENCLOSURE ACT GATEA < 0.062
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE006B{
 @ RULE_GATE006B
 @ Minimum extension of GATE [B] past ACT is 62nm
 ENCLOSURE ACT GATEB < 0.062
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE007A{
@ RULE_GATE007A
@ Minimum length of Gate A (vertical edge, gate C ignored) 200nm
LENGTH GATEA_vertical_edges < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE007B{
@ RULE_GATE007B
@ Minimum length of Gate B (vertical edge, gate C ignored) 200nm
LENGTH GATEB_vertical_edges < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE008A{
@ RULE_GATE008A  
@ (gatea not gatec) maximum distance to neighbor shape on same design mask is 236nm
GateAnotC = GATEA NOT GATEC 
x = SIZE GateAnotC BY 0.237
GATEA NOT x
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE008B{
@ RULE_GATE008B  
@ (gateb not gatec) maximum distance to neighbor shape 236nm
GateBnotC = GATEB NOT GATEC 
x = SIZE GateBnotC BY 0.237
GATEB NOT x 
}

////////////////////////////////////////////////////////////////////////////////////
//____________________________GATE LAYER (without Double Patterning - 1 color) RULES
////////////////////////////////////////////////////////////////////////////////////
GATEAB_HORIZONTAL_EDGES = GATEAB ANGLE == 0
GATEAB_VERTICAL_EDGES = GATEAB ANGLE == 90

RULE_GATE001AB{
 @ RULE_GATE001AB
 @ Exact horizontal width of GATE [AB] is 20, 16 or 14 nm
 INTERNAL GATEAB_VERTICAL_EDGES < 0.014 
 INTERNAL GATEAB_VERTICAL_EDGES > 0.014 < 0.016
 INTERNAL GATEAB_VERTICAL_EDGES > 0.016 < 0.020
 INTERNAL GATEAB_VERTICAL_EDGES > 0.020 < 0.800
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE002AB{
 @ RULE_GATE002AB
 @ Min horizontal pitch of GATE [AB] is 64nm 
 //select vertical edge pairs on same polygons, constraint is 1 to include all edge pairs
 x = INT GATEAB_VERTICAL_EDGES < 1
 //derive centerlines between edge pairs
 y = DFM COPY x CENTERLINE
 //expand the centerlines by a very small value to form very thin polygons
 y_copy = EXPAND EDGE y INSIDE BY 0.001
 //output gate polygons that have a horizontal pitch less than 128nm
 EXT y_copy < 0.063 OPPOSITE
}
//XXX Horizontal pitch should be 64nm and not 128nm
//Min horizontal pitch of GATE [AB] is 128 nm changed to 64nm
//  EXT y_copy < 0.128 OPPOSITE 
//changed to 63nm
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE003AB{
 @ RULE_GATE003AB
 @ Minimum horizontal spacing of GATE[AB] is 44 nm
 EXTERNAL GATEAB_VERTICAL_EDGES < 0.044
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE004AB{
 @ RULE_GATE004AB
 @ GATE[AB] may not bend
 CONVEX EDGE GATEAB ANGLE1 > 90 ANGLE2 > 0 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE005AB{
 @ RULE_GATE005AB
 @ Minimum extension of ACT past GATE [AB] is 38nm
 ENCLOSURE GATEAB ACT < 0.038
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE006AB{
 @ RULE_GATE006AB
 @ Minimum extension of GATE [AB] past ACT is 62nm
 ENCLOSURE ACT (GATEAB NOT GATEC) < 0.062
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE007AB{
@ RULE_GATE007AB
@ Minimum length of Gate AB (vertical edge, gate C ignored) 200nm
LENGTH GATEAB_VERTICAL_EDGES < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE008AB{
@ RULE_GATE008AB  
@ (gateAB not gatec) maximum distance to neighbor shape 236nm
GateABnotC = GATEAB NOT GATEC 
x = SIZE GateABnotC BY 0.237
GATEAB NOT x
}
////////////////////////////////////////////////////////////////////////////////////
//________________________________________________________________GATE C LAYER RULES
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE001Ca{
@ RULE_GATE001Ca
@ Exact vertical width of GATEC is 32nm (1 is arbitrary large value)
@ shape is oriented horizonally
vert_edges = GATEC ANGLE == 90
hor_edges = GATEC ANGLE == 0
vert_edges_int = INT vert_edges < 1
hor_edges_int = INT hor_edges < 1
vert_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
hor_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
hor_edges_hor_pol = hor_polygons angle == 0
INT hor_edges_hor_pol > 0 < 0.032
INT hor_edges_hor_pol > 0.032 < 1
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE001Cb{
@ RULE_GATE001Cb
@ Exact horizontal width of GATEC is 64nm (1 is arbitrary large value)
@ shape is oriented vertically
vert_edges = GATEC ANGLE == 90
hor_edges = GATEC ANGLE == 0
vert_edges_int = INT vert_edges < 1
hor_edges_int = INT hor_edges < 1
vert_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
hor_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
vert_edges_vert_pol = vert_polygons angle == 90
INT vert_edges_vert_pol > 0 < 0.064
INT vert_edges_vert_pol > 0.064 < 1
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE002Ca{
@ RULE_GATE002Ca
@ Minimum horizontal length of GATEC is 128nm
@ shape is oriented horizonatally
vert_edges = GATEC ANGLE == 90
hor_edges = GATEC ANGLE == 0
vert_edges_int = INT vert_edges < 1
hor_edges_int = INT hor_edges < 1
vert_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
hor_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
vert_edges_hor_pol = hor_polygons angle == 90
INT vert_edges_hor_pol < 0.128
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE002Cb{
@ RULE_GATE002Cb
@ Exact vertical length of GATEC is 64nm
@ shape is oriented vertically
vert_edges = GATEC ANGLE == 90
hor_edges = GATEC ANGLE == 0
vert_edges_int = INT vert_edges < 5
hor_edges_int = INT hor_edges < 5
vert_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
hor_polygons = DFM PROPERTY GATEC hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
hor_edges_vert_pol = vert_polygons angle == 0
INT hor_edges_vert_pol >0 < 0.064
INT hor_edges_vert_pol >0.064 < 1
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE003C{
@ RULE_GATE003C
@ Minimum space of GATEC is 128nm
EXTERNAL GATEC < 0.128
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE004Ca{
@ RULE_GATE004Ca
@ Minimum extension of GATEC past GATEA (horizontal direction) is 22nm
gatec_vert_edges = GATEC ANGLE == 90
gatea_vert_edges = GATEA ANGLE == 90
ENC gatea_vert_edges gatec_vert_edges  < 0.022
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE004Cb{
@ RULE_GATE004Cb
@ Minimum extension of GATEC past GATEB (horizontal direction) is 22nm
gatec_vert_edges = GATEC ANGLE == 90
gateb_vert_edges = GATEB ANGLE == 90
ENC gateb_vert_edges gatec_vert_edges < 0.022
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE005C{
@ RULE_GATE005C
@ GATEC minimum space to ACT is 15nm
EXTERNAL GATEC ACT < 0.015
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE006C{
@ RULE_GATE006C
@ GATEC may not bend
CONVEX EDGE GATEC ANGLE1 > 90 ANGLE2 > 0
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GATE007C{
@ RULE_GATE007C
@ GATEC shape bottom or top must be aligned if distance < 192nm
// deriving the region between gatec polygons with spacing < 192nm
ext_region = EXT GATEC < 0.192 REGION
// finding regions that are not rectangular (indicating misalignment of gatec polygons)
angled_edges = ANGLE ext_region >0 <90
angled_regions = ext_region WITH EDGE angled_edges
// output gatec polygons that touch angled regions
GATEC INTERACT angled_regions
}
////////////////////////////////////////////////////////////////////////////////////
//___________________________________________________________________ VTL/VTH LAYERS
////////////////////////////////////////////////////////////////////////////////////
RULE_VT001{
 @ RULE_VT001
 @ Minimum width of VTL/VTH/(not (VTL or VTH)) is 144nm
 // 1 - create a derived layer for the merged combination of these layers' polygons
 DERIVED_LAYER_1 = VTH NOT (VTL OR VTH)
 DERIVED_LAYER_2 = VTL NOT (VTL OR VTH)
 // 1 - Apply the rule on the derived layer
 INTERNAL DERIVED_LAYER_1 < 0.144
 INTERNAL DERIVED_LAYER_2 < 0.144
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VT002{
 @ RULE_VT002
 @ Minimum spacing of VTL/VTH/(not (VTL or VTH)) is 144nm
 // 1 - create a derived layer for the merged combination of these layers' polygons
 DERIVED_LAYER_1 = VTH NOT (VTL OR VTH)
 DERIVED_LAYER_2 = VTL NOT (VTL OR VTH)
 // 1 - Apply the rule on the derived layer
 EXTERNAL DERIVED_LAYER_1 < 0.144
 EXTERNAL DERIVED_LAYER_2 < 0.144
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VTL003A{
 @ RULE_VTL003A
 @ Minimum enclosure of GATEA by VTL is 64nm
 ENCLOSURE VTL GATEA < 0.064
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VTL003B{
 @ RULE_VTL003B
 @ Minimum enclosure of GATEB by VTL is 64nm
 ENCLOSURE VTL GATEB < 0.064
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VTH003A{
 @ RULE_VTH003A
 @ Minimum enclosure of GATEA by VTH is 64nm
 ENCLOSURE GATEA VTH < 0.064
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VTH003B{
 @ RULE_VTH003B
 @ Minimum enclosure of GATEB by VTH is 64nm
 ENCLOSURE GATEB VTH < 0.064
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VTL004A{
 @ RULE_VTL004A
 @ Minimum spacing of GATEA to VTL is 44nm
 EXTERNAL VTL GATEA < 0.044
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VTL004B{
 @ RULE_VTL004B
 @ Minimum spacing of GATEB to VTL is 44nm
 EXTERNAL VTL GATEB < 0.044
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VTH004A{
 @ RULE_VTH004A
 @ Minimum spacing of GATEA to VTH is 44nm
 EXTERNAL VTH GATEA < 0.044
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VTH004B{
 @ RULE_VTH004B
 @ Minimum spacing of GATEB to VTH is 44nm
 EXTERNAL VTH GATEB < 0.044
}


////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________ NIM/PIM LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_NIM001A{
 @ RULE_NIM001A
 @ Minimum width of NIM is 128nm
 INTERNAL NIM <0.128
}
///////////////////////////////////////////////////////////////////////////////////
RULE_NIM001B{
 @ RULE_NIM001B
 @ Minimum Spacing of NIM is 128nm
 EXTERNAL NIM <0.128 SPACE
}
///////////////////////////////////////////////////////////////////////////////////
RULE_NIM001C{
 @ RULE_NIM001C
 @ Minimum Spacing of NIM is 128nm
 EXTERNAL NIM <0.128 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_PIM001A{
 @ RULE_PIM001A
 @ Minimum width of PIM is 128nm
 INTERNAL PIM <0.128
}
/////////////////////////////////////////////////////////////////////////////////
RULE_PIM001B{
 @ RULE_PIM001B
 @ Minimum Spacing of PIM is 128nm
 EXTERNAL PIM <0.128 SPACE
}
/////////////////////////////////////////////////////////////////////////////////
RULE_PIM001C{
 @ RULE_PIM001C
 @ Minimum Spacing of PIM is 128nm
 EXTERNAL PIM <0.128 NOTCH
}
/////////////////////////////////////////////////////////////////////////////////
RULE_NIM002A{
 @ RULE_NIM002A
 @ Minimum spacing of NIM to channel: width of SD at GATE[A] is 32nm
 INTERNAL N_SD_A <0.032
}
/////////////////////////////////////////////////////////////////////////////////
RULE_NIM002B{
 @ RULE_NIM002B
 @ Minimum spacing of NIM to channel: width of SD at GATE[B] is 32nm
 INTERNAL N_SD_B <0.032
}
/////////////////////////////////////////////////////////////////////////////////
RULE_NIM002AB{
 @ RULE_NIM002AB
 @ Minimum spacing of NIM to channel: width of SD at GATE[AB] is 32nm
 INTERNAL N_SD_AB <0.032
}
////////////////////////////////////////////////////////////////////////////////
RULE_PIM002A{
 @ RULE_PIM002A
 @ Minimum spacing of PIM to channel: width of SD at GATE[A] is 32nm
 INTERNAL P_SD_A <0.032
}
////////////////////////////////////////////////////////////////////////////////
RULE_PIM002B{
 @ RULE_PIM002B
 @ Minimum spacing of PIM to channel: width of SD at GATE[B] is 32nm
 INTERNAL P_SD_B <0.032
}
////////////////////////////////////////////////////////////////////////////////
RULE_PIM002AB{
 @ RULE_PIM002AB
 @ Minimum spacing of PIM to channel: width of SD at GATE[AB] is 32nm
 INTERNAL P_SD_AB <0.032
}
////////////////////////////////////////////////////////////////////////////////
RULE_NIM003A{
 @ RULE_NIM003A
 @ Minimum Extension of NIM past channel (Horizontal Direction): Overlap between Gate[A] and NIM  is 32nm
 ALL_EXTENSION_NIM_HORIZ_EDGES_A = ANGLE N_EXT_N_GATE_A == 90
 INTERNAL ALL_EXTENSION_NIM_HORIZ_EDGES_A < 0.032
}
//XXX  ALL_EXTENSION_NIM_HORIZ_EDGES_A = ANGLE N_GATE_A == 90
//changed to  ALL_EXTENSION_NIM_HORIZ_EDGES_A = ANGLE N_EXT_N_GATE_A == 90
////////////////////////////////////////////////////////////////////////////////
RULE_NIM003B{
 @ RULE_NIM003B
 @ Minimum Extension of NIM past channel (Horizontal Direction): Overlap between Gate[B] and NIM  is 32nm
 ALL_EXTENSION_NIM_HORIZ_EDGES_B = ANGLE N_EXT_N_GATE_B == 90
 INTERNAL ALL_EXTENSION_NIM_HORIZ_EDGES_B < 0.032
}
//XXX  ALL_EXTENSION_NIM_HORIZ_EDGES_B = ANGLE N_GATE_B == 90
//changed to  ALL_EXTENSION_NIM_HORIZ_EDGES_B = ANGLE N_EXT_N_GATE_B == 90
////////////////////////////////////////////////////////////////////////////////
RULE_PIM003A{
 @ RULE_PIM003A
 @ Minimum Extension of NIM past channel (Horizontal Direction): Overlap between Gate[A] and NIM  is 32nm
 ALL_EXTENSION_PIM_HORIZ_EDGES_A = ANGLE P_EXT_P_GATE_A == 90
 INTERNAL ALL_EXTENSION_PIM_HORIZ_EDGES_A < 0.032
}
//XXX  ALL_EXTENSION_PIM_HORIZ_EDGES_A = ANGLE P_GATE_A == 90
/// changed to  ALL_EXTENSION_PIM_HORIZ_EDGES_A = ANGLE P_EXT_P_GATE_A == 90
////////////////////////////////////////////////////////////////////////////////
RULE_PIM003B{
 @ RULE_PIM003B
 @ Minimum Extension of NIM past channel (Horizontal Direction): Overlap between Gate[B] and NIM  is 32nm
 ALL_EXTENSION_PIM_HORIZ_EDGES_B = ANGLE P_EXT_P_GATE_B == 90
 INTERNAL ALL_EXTENSION_PIM_HORIZ_EDGES_B < 0.032
}
///XXX  ALL_EXTENSION_PIM_HORIZ_EDGES_B = ANGLE P_GATE_B == 90
/// changed to ALL_EXTENSION_PIM_HORIZ_EDGES_B = ANGLE P_EXT_P_GATE_B == 90
///////////////////////////////////////////////////////////////////////////////
RULE_NIM004A{
 @ RULE_NIM004A
 @ Minimum Extension of NIM past channel (Vertical Direction): Overlap between Gate[A] and NIM  is 30nm
 ALL_EXTENSION_NIM_VERT_EDGES_A = ANGLE N_GATE_A == 0
 INTERNAL ALL_EXTENSION_NIM_VERT_EDGES_A < 0.030
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_NIM004B{
 @ RULE_NIM004B
 @ Minimum Extension of NIM past channel (Vertical Direction): Overlap between Gate[B] and NIM  is 30nm
 ALL_EXTENSION_NIM_VERT_EDGES_B = ANGLE N_GATE_B == 0
 INTERNAL ALL_EXTENSION_NIM_VERT_EDGES_B < 0.030
}
////////////////////////////////////////////////////////////////////////////////////
RULE_PIM004A{
 @ RULE_PIM004A
 @ Minimum Extension of NIM past channel (Vertical Direction): Overlap between Gate[A] and NIM  is 30nm
 ALL_EXTENSION_PIM_VERT_EDGES_A = P_GATE_A ANGLE  == 0
 INTERNAL ALL_EXTENSION_PIM_VERT_EDGES_A < 0.030
}
////////////////////////////////////////////////////////////////////////////////////
RULE_PIM004B{
 @ RULE_PIM004B
 @ Minimum Extension of NIM past channel (Vertical Direction): Overlap between Gate[B] and NIM  is 30nm
 ALL_EXTENSION_PIM_VERT_EDGES_B = ANGLE P_GATE_B == 0
 INTERNAL ALL_EXTENSION_PIM_VERT_EDGES_B < 0.030
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NIM005{
 @ RULE_NIM005
 @ Minimum spacing of NIM to (ACT enclosed by PIM) is 0.030 um
 ACT_ENCLOSED_PIM = ACT INSIDE PIM
 EXTERNAL NIM ACT_ENCLOSED_PIM < 0.03
}
////////////////////////////////////////////////////////////////////////////////////
RULE_PIM005{
 @ RULE_PIM005
 @ Minimum spacing of PIM to (ACT enclosed by NIM) is 0.030 um
 ACT_ENCLOSED_NIM = ACT INSIDE NIM
 EXTERNAL PIM ACT_ENCLOSED_NIM < 0.03
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NIM006{
 @ RULE_NIM006
 @ Minimum enclosure of ACT by NIM is 0.030 um
 ENCLOSURE ACT NIM  < 0.030
}
////////////////////////////////////////////////////////////////////////////////////
RULE_PIM006{
 @ RULE_PIM006
 @ Minimum enclosure of ACT by PIM is 0.030 um
 ENCLOSURE ACT PIM  < 0.030
}
////////////////////////////////////////////////////////////////////////////////////
RULE_NIM007A{
 @ RULE_NIM007A
 @ Minimum area of NIM is 0.049 um2
 AREA NIM  < 0.049
}
///////////////////////////////////////////////////////////////////////////////////
RULE_NIM007B{
 @ RULE_NIM007B
 @ Minimum enclosed area of NIM is 0.049 um2
 HOLES NIM < 0.049
}
///////////////////////////////////////////////////////////////////////////////////
RULE_PIM007A{
 @ RULE_PIM007A
 @ Minimum area of PIM is 0.049 um2
 AREA PIM  < 0.049
}
///////////////////////////////////////////////////////////////////////////////////
RULE_PIM007B{
 @ RULE_PIM007B
 @ Minimum enclosed area of PIM is 0.049 um2
 HOLES PIM < 0.049
}
////////////////////////////////////////////////////////////////////////////////////
//_______________________________________________________________________ AIL1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1001{
 @ RULE_AIL1001
 @ Horizontal Width of AIL1 is 28nm
 AIL1_VERTICAL_EDGES = AIL1 ANGLE == 90 
 INTERNAL AIL1_VERTICAL_EDGES < 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1002{
 @ RULE_AIL1002
 @ Horizontal spacing of AIL1 is 36nm
 AIL1_VERTICAL_EDGES = AIL1 ANGLE == 90 
 EXTERNAL AIL1_VERTICAL_EDGES < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1003A{
 @ RULE_AIL1003A
 @ Minimum spacing of AIL1 to GATE[A] is 8nm
 EXTERNAL AIL1 GATEA < 0.008
}
///////////////////////////////////////////////////////////////////////////////////
RULE_AIL1003B{
 @ RULE_AIL1003B
 @ Minimum spacing of AIL1 to GATE[B] is 8nm
 EXTERNAL AIL1 GATEB < 0.008
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1004{
 @ RULE_AIL1004
 @ Minimum extenxion of ACT past AIL1 in horizontal direction is 2nm
 AIL1_VERTICAL_EDGES = AIL1 ANGLE == 90 
 ENC AIL1_VERTICAL_EDGES ACT < 0.002
}
//XXX  ENC ACT AIL1_VERTICAL_EDGES < 0.002  
//changed to ENC AIL1_VERTICAL_EDGES ACT < 0.002 
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1005{
 @ RULE_AIL1005
 @ Minimum Vertical length of AIL1 is 58nm
 AIL1_HORIZONTAL_EDGES = AIL1 ANGLE == 0 
 INTERNAL AIL1_HORIZONTAL_EDGES < 0.058 
}
////////////////////////////////////////////////////////////////////////////////////

RULE_AIL1006{
 @ RULE_AIL1006
 @ Minimum Vertical spacing of AIL1 is 62nm
 AIL1_HORIZONTAL_EDGES = AIL1 ANGLE == 0 
 EXTERNAL AIL1_HORIZONTAL_EDGES < 0.062 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1007{
 @ RULE_AIL1007
 @ Minimum Vertical extension of AIL1 past ACT is 0nm
   AIL1_HORIZONTAL_EDGES = AIL1 ANGLE==0
  INSIDE EDGE AIL1_HORIZONTAL_EDGES ACT
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL1008{
 @ RULE_AIL1008
 @ AIL1 layer may not bend
 CONVEX EDGE AIL1 ANGLE1 > 90 ANGLE2 > 0 
}
////////////////////////////////////////////////////////////////////////////////////
//_______________________________________________________________________ AIL2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2001{
 @ RULE_AIL2001
 @ Horizontal width of AIL2 is 24nm
 AIL2_VERTICAL_EDGES = AIL2 ANGLE == 90 
 INTERNAL AIL2_VERTICAL_EDGES < 0.024 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2002{
 @ RULE_AIL2002
 @ Horizontal spacing of AIL2 is 40nm
 AIL2_VERTICAL_EDGES = AIL2 ANGLE == 90 
 EXTERNAL AIL2_VERTICAL_EDGES < 0.040 
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2003A{
 @ RULE_AIL2003A
 @ Minimum spacing between AIL2 and GATE[A]
 EXTERNAL AIL2 GATEA < 0.01
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2003B{
 @ RULE_AIL2003B
 @ Minimum spacing between AIL2 and GATE[B]
 EXTERNAL AIL2 GATEB < 0.01
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2004{
 @ RULE_AIL2004
 @ Minimum horizontal enclosure of AIL1 around AIL2 is 2 nm
 AIL1_VERTICAL_EDGES = AIL1 ANGLE == 90 
 ENC AIL1_VERTICAL_EDGES AIL2 < 0.002
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2005{
 @ RULE_AIL2005
 @ Minimum Vertical overlap of AIL1 and AIL2 is 58nm
 OVERLAP_HORIZONTAL_EDGES = AIL_OVERLAP ANGLE == 0
 INT OVERLAP_HORIZONTAL_EDGES < 0.058 
 
// AIL1_HORIZONTAL_EDGES = AIL1 ANGLE == 0  
}
//ENC AIL1_HORIZONTAL_EDGES AIL2  < 0.058 ABUT==0
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2006{
 @ RULE_AIL2006
 @ Vertical length of AIL2 is 68nm
 AIL2_HORIZ_EDGES = AIL2 ANGLE == 0 
 INTERNAL AIL2_HORIZ_EDGES < 0.068
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2007{
 @ RULE_AIL2007
 @ Vertical spacing of AIL2 is 62nm
 AIL2_HORIZONTAL_EDGES = AIL2 ANGLE == 0 
 EXTERNAL AIL2_HORIZONTAL_EDGES < 0.062 OPPOSITE
}
// Angle made 0 from 90
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2008{
 @ RULE_AIL2008
 @ AIL2 may not bend
 CONVEX EDGE AIL2 ANGLE1 > 90 ANGLE2 > 0 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_AIL2009{
 @ RULE_AIL2009
 @ Minimum horizontal spacing of AIL1 and AIL2 is 38nm
 AIL1_VERTICAL_EDGES = AIL1 ANGLE == 90 
 AIL2_VERTICAL_EDGES = AIL2 ANGLE == 90 
 EXTERNAL AIL1_VERTICAL_EDGES AIL2_VERTICAL_EDGES < 0.038 NOT CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_AIL2010{
 @ RULE_AIL2009
 @ Minimum vertical spacing of AIL1 and AIL2 is 62nm
 AIL1_HORIZONTAL_EDGES = AIL1 ANGLE == 0 
 AIL2_HORIZONTAL_EDGES = AIL2 ANGLE == 0 
 EXTERNAL AIL1_HORIZONTAL_EDGES AIL2_HORIZONTAL_EDGES < 0.062 NOT CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
//________________________________________________________________________ GIL LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL001{
 @ RULE_GIL001A
 @ Minimum vertical width of GIL is 44nm
 ALL_HORIZ_EDGES = ANGLE GIL == 0
 INTERNAL ALL_HORIZ_EDGES < 0.044
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL002{
 @ RULE_GIL001B
 @ Minimum horizontal length of GIL is 56nm
 ALL_VERT_EDGES = ANGLE GIL == 90
 INTERNAL ALL_VERT_EDGES < 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL003{
 @ RULE_GIL003
 @ Minimum vertical spacing of GIL is 32nm
 ALL_HORIZ_EDGES = ANGLE GIL == 0
 EXTERNAL ALL_HORIZ_EDGES < 0.032
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL004{
 @ RULE_GIL004
 @ Minimum horizontal spacing of GIL is 40nm
 ALL_VERT_EDGES = ANGLE GIL == 90
 EXTERNAL ALL_VERT_EDGES < 0.040
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL005{
 @ RULE_GIL005
 @ Minimum vertical spacing of GIL to ACT is 6nm
 ALL_HORIZ_EDGES = ANGLE GIL == 0
 EXTERNAL ALL_HORIZ_EDGES ACT < 0.006
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL006A{
 @ RULE_GIL006A
 @ Minimum horizontal extension of GIL past GATE[A] is 2nm
 GIL_VERTICAL_EDGES = GIL ANGLE == 90 
 ENC GATEA GIL_VERTICAL_EDGES < 0.002
}
 
// XXX ENC GIL_VERTICAL_EDGES GATEA < 0.002 changed to
// ENC GATEA GIL_VERTICAL_EDGES < 0.002
///////////////////////////////////////////////////////////////////////////////////
RULE_GIL006B{
 @ RULE_GIL006B
 @ Minimum horizontal extension of GIL past GATE[B] is 2nm
 GIL_VERTICAL_EDGES = GIL ANGLE == 90 
 ENC GIL_VERTICAL_EDGES GATEB < 0.002
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL007{
 @ RULE_GIL007
 @ Minimum horizontal space of GIL to AIL2 is 8nm
 GIL_VERTICAL_EDGES = GIL ANGLE == 90 
 EXT GIL_VERTICAL_EDGES AIL2 < 0.008 NOT CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL008{
 @ RULE_GIL008
 @ Minimum vertical space of GIL to AIL2 is 32nm
 GIL_HORIZONTAL_EDGES = GIL ANGLE == 0 
 EXT GIL_HORIZONTAL_EDGES AIL2 < 0.032
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL009A{
 @ RULE_GIL009A
 @ Minimum horizontal space of GIL to GATE[A] is 10nm
 GIL_VERTICAL_EDGES = GIL ANGLE == 90 
 EXT GIL_VERTICAL_EDGES GATEA < 0.010
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL009B{
 @ RULE_GIL009B
 @ Minimum horizontal space of GIL to GATE[B] is 10nm
 GIL_VERTICAL_EDGES = GIL ANGLE == 90 
 EXT GIL_VERTICAL_EDGES GATEB < 0.010
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL2010{
 @ RULE_GIL2010
 @ Minimum Vertical overlap of GIL and AIL2 is 24nm
 AIL2_VERTICAL_EDGES = AIL2 ANGLE == 90 
 ENC AIL2_VERTICAL_EDGES GIL < 0.024 CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL011{
 @ RULE_GIL011
 @ Minimum vertical extension of AIL2 past GIL is 4nm
 AIL2_HORIZONTAL_EDGES = AIL2 ANGLE == 0 
 ENC GIL AIL2_HORIZONTAL_EDGES < 0.004
}
// XXX ENC AIL2_HORIZONTAL_EDGES GIL < 0.004
//changed to  ENC GIL AIL2_HORIZONTAL_EDGES < 0.004
////////////////////////////////////////////////////////////////////////////////////
RULE_GIL012{
 @ RULE_GIL012
 @ GIL may not bend
 CONVEX EDGE GIL ANGLE1 > 90 ANGLE2 > 0 
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V0 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V0001a{
@ RULE_V0001a
@ V0 is a square with 28nm edge length
RECTANGLE V0 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0001bA{
@ RULE_V0001bA
@ V0 is a rectangle 28nm x 56nm when enclosed in M1A with width >= 60nm
wide_M1A = M1A WITH WIDTH >= 0.060
v0_wide_M1A = v0 INSIDE wide_M1A
RECTANGLE v0_wide_M1A != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0001bB{
@ RULE_V0001bB
@ V0 is a rectangle 28nm x 56nm when enclosed in M1B with width >= 60nm
wide_M1B = M1B WITH WIDTH >= 0.060
v0_wide_M1B = v0 INSIDE wide_M1B
RECTANGLE v0_wide_M1B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0002GA{
 @ RULE_V0002GA
 @ Minimum spacing of V0 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between GIL and M1, and GIL is vertical 
 GIL_M1A = GIL AND M1A
 // deriving edges of the intersection
 GIL_M1A_EDGES = ANGLE GIL_M1A == 90
 // identifying edges with runlength = 28nm
 GIL_M1A_EDGES_LENGTH = PATH LENGTH GIL_M1A_EDGES == 0.028
 // forming polygons out of those edges
 GIL_M1A_polygons = GIL WITH EDGE GIL_M1A_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_GIL_M1A = V0 INTERACT GIL_M1A_polygons
 // Finding spacing
 EXT V0_GIL_M1A < 0.036
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0002AA{
 @ RULE_V0002AA
 @ Minimum spacing of V0 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between AIL2 and M1, and AIL2 is vertical 
 AIL2_M1A = AIL2 AND M1A
 // deriving edges of the intersection
 AIL2_M1A_EDGES = ANGLE AIL2_M1A == 90
 // identifying edges with runlength = 28nm
 AIL2_M1A_EDGES_LENGTH = PATH LENGTH AIL2_M1A_EDGES == 0.028
 // forming polygons out of those edges
 AIL2_M1A_polygons = AIL2 WITH EDGE AIL2_M1A_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_AIL2_M1A = V0 INTERACT AIL2_M1A_polygons
 // Finding spacing
 EXT V0_AIL2_M1A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0002GB{
 @ RULE_V0002GB
 @ Minimum spacing of V0 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between GIL and M1, and GIL is vertical 
 GIL_M1B = GIL AND M1B
 // deriving edges of the intersection
 GIL_M1B_EDGES = ANGLE GIL_M1B == 90
 // identifying edges with runlength = 28nm
 GIL_M1B_EDGES_LENGTH = PATH LENGTH GIL_M1B_EDGES == 0.028
 // forming polygons out of those edges
 GIL_M1B_polygons = GIL WITH EDGE GIL_M1B_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_GIL_M1B = V0 INTERACT GIL_M1B_polygons
 // Finding spacing
 EXT V0_GIL_M1B < 0.036
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0002AB{
 @ RULE_V0002AB
 @ Minimum spacing of V0 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between AIL2 and M1, and AIL2 is vertical 
 AIL2_M1B = AIL2 AND M1B
 // deriving edges of the intersection
 AIL2_M1B_EDGES = ANGLE AIL2_M1B == 90
 // identifying edges with runlength = 28nm
 AIL2_M1B_EDGES_LENGTH = PATH LENGTH AIL2_M1B_EDGES == 0.028
 // forming polygons out of those edges
 AIL2_M1B_polygons = AIL2 WITH EDGE AIL2_M1B_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_AIL2_M1B = V0 INTERACT AIL2_M1B_polygons
 // Finding spacing
 EXT V0_AIL2_M1B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0003GA{
 @ RULE_V0003GA
 @ Minimum spacing of V0 if runlength < 28nm is 50nm
 // assuming runlength is the common length between GIL and M1, and GIL is vertical 
 GIL_M1A = GIL AND M1A
 // deriving edges of the intersection
 GIL_M1A_EDGES = ANGLE GIL_M1A == 90
 // identifying edges with runlength < 28nm
 GIL_M1A_EDGES_LENGTH = PATH LENGTH GIL_M1A_EDGES < 0.028
 // forming polygons out of those edges
 GIL_M1A_polygons = GIL WITH EDGE GIL_M1A_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_GIL_M1A = V0 INTERACT GIL_M1A_polygons
 // Finding spacing
 EXT V0_GIL_M1A < 0.050
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0003AA{
 @ RULE_V0003AA
 @ Minimum spacing of V0 if runlength < 28nm is 50nm
 // assuming runlength is the common length between AIL2 and M1, and AIL2 is vertical 
 AIL2_M1A = AIL2 AND M1A
 // deriving edges of the intersection
 AIL2_M1A_EDGES = ANGLE AIL2_M1A == 90
 // identifying edges with runlength = 28nm
 AIL2_M1A_EDGES_LENGTH = PATH LENGTH AIL2_M1A_EDGES < 0.028
 // forming polygons out of those edges
 AIL2_M1A_polygons = AIL2 WITH EDGE AIL2_M1A_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_AIL2_M1A = V0 INTERACT AIL2_M1A_polygons
 // Finding spacing
 EXT V0_AIL2_M1A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0003GB{
 @ RULE_V0003GB
 @ Minimum spacing of V0 if runlength < 28nm is 50nm
 // assuming runlength is the common length between GIL and M1, and GIL is vertical 
 GIL_M1B = GIL AND M1B
 // deriving edges of the intersection
 GIL_M1B_EDGES = ANGLE GIL_M1B == 90
 // identifying edges with runlength = 28nm
 GIL_M1B_EDGES_LENGTH = PATH LENGTH GIL_M1B_EDGES < 0.028
 // forming polygons out of those edges
 GIL_M1B_polygons = GIL WITH EDGE GIL_M1B_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_GIL_M1B = V0 INTERACT GIL_M1B_polygons
 // Finding spacing
 EXT V0_GIL_M1B < 0.050
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V0003AB{
 @ RULE_V0003AB
 @ Minimum spacing of V0 if runlength < 28nm is 50nm
 // assuming runlength is the common length between AIL2 and M1, and AIL2 is vertical 
 AIL2_M1B = AIL2 AND M1B
 // deriving edges of the intersection
 AIL2_M1B_EDGES = ANGLE AIL2_M1B == 90
 // identifying edges with runlength = 28nm
 AIL2_M1B_EDGES_LENGTH = PATH LENGTH AIL2_M1B_EDGES < 0.028
 // forming polygons out of those edges
 AIL2_M1B_polygons = AIL2 WITH EDGE AIL2_M1B_EDGES_LENGTH
 // finding V0 that interact with the formed polygons
 V0_AIL2_M1B = V0 INTERACT AIL2_M1B_polygons
 // Finding spacing
 EXT V0_AIL2_M1B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0004{
@ RULE_V0004
@ V0 must be inside [AIL2|GIL] and M1[A|B]
layer_intersections = OR (AIL2 AND M1A) (AIL2 AND M1B) (GIL AND M1A) (GIL AND M1B)
V0 OUTSIDE layer_intersections
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0005a{
@ RULE_V0005a
@ V0 enclosure by AIL2 in 2 opposite sides, horizontal direction 2nm
v0_vertical_edges = v0 ANGLE ==90
AIL2_vertical_edges = AIL2 ANGLE ==90
ENC v0_vertical_edges AIL2_vertical_edges < 0.002
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0005b{
@ RULE_V0005b
@ V0 enclosure by AIL2 in 2 opposite sides, vertical direction 20nm
v0_horizontal_edges = v0 ANGLE ==0
AIL2_horizontal_edges = AIL2 ANGLE ==0
ENC v0_horizontal_edges AIL2_horizontal_edges < 0.020
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0006a{
@ RULE_V0006a
@ V0 enclosure by (GIL AND AIL2) on 2 opposite sides, horizontal direction 2nm
GIL_AIL2 = GIL AND AIL2
v0_vertical_edges = v0 ANGLE ==90
GIL_AIL2_vert_edges = GIL_AIL2 ANGLE==90
ENC v0_vertical_edges GIL_AIL2_vert_edges < 0.002
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0006b{
@ RULE_V0006b
@ V0 enclosure by (GIL AND AIL2) on 2 opposite sides, vertical direction 8nm
GIL_AIL2 = GIL AND AIL2
v0_horizontal_edges = v0 ANGLE ==0
GIL_AIL2_hor_edges = GIL_AIL2 ANGLE==0
ENC v0_horizontal_edges GIL_AIL2_hor_edges < 0.008
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0007a{
@ RULE_V0007a
@ V0 enclosure by (GIL NOT AIL2) on 2 opposite sides, horizontal direction 14nm
GIL_NOT_AIL2 = GIL NOT AIL2
v0_vertical_edges = v0 ANGLE ==90
GIL_NOT_AIL2_vert_edges = GIL_NOT_AIL2 ANGLE==90
ENC v0_vertical_edges GIL_NOT_AIL2_vert_edges < 0.014
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0007b{
@ RULE_V0006b
@ V0 enclosure by (GIL NOT AIL2) on 2 opposite sides, vertical direction 8nm
GIL_NOT_AIL2 = GIL NOT AIL2
v0_horizontal_edges = v0 ANGLE ==0
GIL_NOT_AIL2_hor_edges = GIL_NOT_AIL2 ANGLE==0
ENC v0_horizontal_edges GIL_NOT_AIL2_hor_edges < 0.008
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0008{
@ RULE_V0008
@ Min spacing of V0 and AIL2 on different net is 38nm
EXT V0 AIL2 < 0.038 NOT CONNECTED
}
/////////////////////////////////////////////////////////////////////////////////////
RULE_V0009{
@ RULE_V0009
@ Min spacing of V0 and GIL on different net is 38nm
EXT V0 GIL < 0.038 NOT CONNECTED
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V0010{
@ RULE_V0010
@ V0 enclosed by GIL may not overlap with (GATE[A|B] over ACT)
V0_in_GIL = V0 INSIDE GIL 
GATEAB_ACT = (GATEA AND ACT) OR (GATEB AND ACT)
V0_in_GIL INTERACT GATEAB_ACT
}

////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ METAL1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_M1001A{
@ RULE_M1001A
@ M1A width 28nm, 32nm, 40nm, 2.4um (10um is arbitrary)
INTERNAL M1A < 0.028
}
//XXX INTERNAL M1A < 0.028
//INTERNAL M1A > 0.028 < 0.032
//INTERNAL M1A > 0.032 < 0.040
//INTERNAL M1A > 0.040 < 2.400
//INTERNAL M1A > 2.4 < 10
///////////////////////////////////////////////////////////////////////////////////
RULE_M1001B{
@ RULE_M1001B
@ M1B width 28nm, 32nm, 40nm, 2.4um (10um is arbitrary)
INTERNAL M1B < 0.028
}
//XXX INTERNAL M1A < 0.028
//INTERNAL M1A > 0.028 < 0.032
//INTERNAL M1A > 0.032 < 0.040
//INTERNAL M1A > 0.040 < 2.400
//INTERNAL M1A > 2.4 < 10
//changed to INTERNAL M1A < 0.028
///////////////////////////////////////////////////////////////////////////////////
RULE_M1002A{
@ RULE_M1002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE M1A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1002B{
@ RULE_M1002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE M1B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1003A{
@ RULE_M1003A
@ maximum length of M1A for wires with min width 28nm is 960nm
wide_M1A = M1A with width <= 0.028
d = INT wide_M1A <= 1 opposite
d_p = dfm property wide_M1A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_M1003B{
@ RULE_M1003B
@ maximum length of M1B for wires with min width 28nm is 960nm
wide_M1B = M1B with width <= 0.028
d = INT wide_M1B <= 1 opposite
d_p = dfm property wide_M1B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_M1004A{
@ RULE_M1004A
@ M1A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
M1A_eol = LENGTH M1A < 0.032
EXT M1A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1004B{
@ RULE_M1004B
@ M1B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
M1B_eol = LENGTH M1B < 0.032
EXT M1B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1005A{
@ RULE_M1005A
@ M1A min space and notch 54nm
EXT M1A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1005B{
@ RULE_M1005B
@ M1B min space and notch 54nm
EXT M1B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_M1006{
@ RULE_M1006
@ min spacing of M1A to M1B 36nm
EXT M1A M1B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1007{
@ RULE_M1007
@ End-of-line spacing of M1A to M1B (EOL edge defined as edge < 32nm) is 44nm
M1A_eol = LENGTH M1A < 0.032
M1B_eol = LENGTH M1B < 0.032
EXT M1A_eol M1B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1008A{
@ RULE_M1008A
@ Minimum spacing of M1A when M1A is wider than 32nm and longer than 240nm is 68nm
M1A_wide = M1A WITH WIDTH > 0.032
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1008B{
@ RULE_M1008B
@ Minimum spacing of M1B when M1B is wider than 32nm and longer than 240nm is 68nm
M1B_wide = M1B WITH WIDTH > 0.032
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1009A{
@ RULE_M1009A
@ Minimum spacing of M1A when M1A is wider than 40nm and longer than 240nm is 76nm
M1A_wide = M1A WITH WIDTH > 0.040
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1009B{
@ RULE_M1009B
@ Minimum spacing of M1B when M1B is wider than 40nm and longer than 240nm is 76nm
M1B_wide = M1B WITH WIDTH > 0.040
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1010A{
@ RULE_M1010A
@ Minimum spacing of M1A when M1A is wider than 64nm and longer than 480nm is 92nm
M1A_wide = M1A WITH WIDTH > 0.064
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p M1A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1010B{
@ RULE_M1010B
@ Minimum spacing of M1B when M1B is wider than 64nm and longer than 480nm is 92nm
M1B_wide = M1B WITH WIDTH > 0.064
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p M1B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1011A{
@ RULE_M1011A
@ Minimum spacing of M1A when M1A is wider than 120nm and longer than 1200nm is 120nm
M1A_wide = M1A WITH WIDTH > 0.120
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p M1A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1011B{
@ RULE_M1011B
@ Minimum spacing of M1B when M1B is wider than 120nm and longer than 1200nm is 120nm
M1B_wide = M1B WITH WIDTH > 0.120
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p M1B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1012A{
@ RULE_M1012A
@ Minimum spacing of M1A when M1A is wider than 240nm and longer than 1800nm is 240nm
M1A_wide = M1A WITH WIDTH > 0.240
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p M1A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1012B{
@ RULE_M1012B
@ Minimum spacing of M1B when M1B is wider than 240nm and longer than 1800nm is 240nm
M1B_wide = M1B WITH WIDTH > 0.240
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p M1B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1013A{
@ RULE_M1013A
@ Minimum spacing of M1A when M1A is wider than 320nm and longer than 2400nm is 320nm
M1A_wide = M1A WITH WIDTH > 0.320
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1013B{
@ RULE_M1013B
@ Minimum spacing of M1B when M1B is wider than 320nm and longer than 2400nm is 320nm
M1B_wide = M1B WITH WIDTH > 0.320
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1014A{
@ RULE_M1014A
@ Minimum spacing of M1A when M1A is wider than 600nm and longer than 2400nm is 600nm
M1A_wide = M1A WITH WIDTH > 0.600
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1014B{
@ RULE_M1014B
@ Minimum spacing of M1B when M1B is wider than 600nm and longer than 2400nm is 600nm
M1B_wide = M1B WITH WIDTH > 0.600
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1015A{
@ RULE_M1015A
@ Minimum spacing of M1A to M1B when M1B is wider than 32nm and longer than 240nm is 44nm
M1B_wide = M1B WITH WIDTH > 0.032
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1015B{
@ RULE_M1015B
@ Minimum spacing of M1B to M1A when M1A is wider than 32nm and longer than 240nm is 44nm
M1A_wide = M1A WITH WIDTH > 0.032
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1016A{
@ RULE_M1016A
@ Minimum spacing of M1A to M1B when M1B is wider than 40nm and longer than 240nm is 50nm
M1B_wide = M1B WITH WIDTH > 0.040
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1016B{
@ RULE_M1016B
@ Minimum spacing of M1B to M1A when M1A is wider than 40nm and longer than 240nm is 50nm
M1A_wide = M1A WITH WIDTH > 0.040
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p M1B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1017A{
@ RULE_M1017A
@ Minimum spacing of M1A to M1B when M1B is wider than 64nm and longer than 480nm is 60nm
M1B_wide = M1B WITH WIDTH > 0.064
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p M1A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1017B{
@ RULE_M1017B
@ Minimum spacing of M1B to M1A when M1A is wider than 64nm and longer than 480nm is 60nm
M1A_wide = M1A WITH WIDTH > 0.064
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p M1B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1018A{
@ RULE_M1018A
@ Minimum spacing of M1A to M1B when M1B is wider than 120nm and longer than 1200nm is 78nm
M1B_wide = M1B WITH WIDTH > 0.120
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p M1A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1018B{
@ RULE_M1018B
@ Minimum spacing of M1B to M1A when M1A is wider than 120nm and longer than 1200nm is 78nm
M1A_wide = M1A WITH WIDTH > 0.120
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p M1B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1019A{
@ RULE_M1019A
@ Minimum spacing of M1A to M1B when M1B is wider than 240nm and longer than 1800nm is 156nm
M1B_wide = M1B WITH WIDTH > 0.240
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p M1A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1019B{
@ RULE_M1019B
@ Minimum spacing of M1B to M1A when M1A is wider than 240nm and longer than 1800nm is 156nm
M1A_wide = M1A WITH WIDTH > 0.240
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p M1B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1020A{
@ RULE_M1020A
@ Minimum spacing of M1A to M1B when M1B is wider than 320nm and longer than 2400nm is 200nm
M1B_wide = M1B WITH WIDTH > 0.320
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1020B{
@ RULE_M1020B
@ Minimum spacing of M1B to M1A when M1A is wider than 320nm and longer than 2400nm is 200nm
M1A_wide = M1A WITH WIDTH > 0.320
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1021A{
@ RULE_M1021A
@ Minimum spacing of M1A to M1B when M1B is wider than 600nm and longer than 2400nm is 400nm
M1B_wide = M1B WITH WIDTH > 0.600
d = INT M1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1021B{
@ RULE_M1021B
@ Minimum spacing of M1B to M1A when M1A is wider than 600nm and longer than 2400nm is 400nm
M1A_wide = M1A WITH WIDTH > 0.600
d = INT M1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY M1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p M1B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1022{
@ RULE_M1022
@ Minimum overlap of M1A and M1B (stitch region length)
M1AB_stitch = M1A AND M1B
INT M1AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1023A{
@ RULE_M1023A
@ Allowed enclosures of V0 by M1A
RECTANGLE ENCLOSURE V0 M1A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX RECTANGLE ENCLOSURE V0 M1A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 M1A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_M1023B{
@ RULE_M1023B
@ Allowed enclosures of V0 by M1B
RECTANGLE ENCLOSURE V0 M1B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX RECTANGLE ENCLOSURE V0 M1B ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 M1B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_M1024{
@ RULE_M1024
@ Allowed enclosures of V0 by M1A-M1B stitches
M1AB_stitch = M1A AND M1B
RECTANGLE ENCLOSURE V0 M1AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
/// XXX RECTANGLE ENCLOSURE V0 M1AB ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 M1AB ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
//RULE_M1025A{
//@ RULE_M1025A
//@ V0 center must be aligned to wire center (between 2 longest edges)
//V0_M1A_OVERLAP = V0 AND M1A
// deriving metal and via edge pairs
//M1A_edges = INT M1A < 1
//V0_edges = INT V0 < 1
// deriving metal and via center lines
//M1A_centerline = DFM COPY M1A_edges CENTERLINE
//V0_centerline = DFM COPY V0_edges CENTERLINE
// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = M1A_centerline COIN EDGE V0_centerline
// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
// output vias that do not interact with the formed polygons
//V0_M1A_OVERLAP NOT INTERACT y
//}
//XXX V0 NOT INTERACT y 
// changed to V0_M1A_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
//RULE_M1025B{
//@ RULE_M1025B
//@ V0 center must be aligned to wire center (between 2 longest edges)
//V0_M1B_OVERLAP = V0 AND M1B
//// deriving metal and via edge pairs
//M1B_edges = INT M1B < 1
//V0_edges = INT V0 < 1
//// deriving metal and via center lines
//M1B_centerline = DFM COPY M1B_edges CENTERLINE
//V0_centerline = DFM COPY V0_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = M1B_centerline COIN EDGE V0_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V0_M1B_OVERLAP NOT INTERACT y
////V0_overlap_m1b
//}
//XXX V0 NOT INTERACT y 
// changed to V0_M1B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_M1026A{
@ RULE_M1026A
@ V0 shape must be rectangular if enclosing M1A wire width >= 60nm
wide_M1A = M1A WITH WIDTH >= 0.060
V0_in_wideM1A = V0 INSIDE wide_M1A
NOT RECTANGLE V0_in_wideM1A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1026B{
@ RULE_M1026B
@ V0 shape must be rectangular if enclosing M1B wire width >= 60nm
wide_M1B = M1B WITH WIDTH >= 0.060
V0_in_wideM1B = V0 INSIDE wide_M1B
NOT RECTANGLE V0_in_wideM1B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_M1027A{
@ RULE_M1027A
@ M1A minimum area for rectangular shape is 0.0024um2
rect_M1A = RECTANGLE M1A
AREA rect_M1A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_M1027B{
@ RULE_M1027B
@ M1B minimum area for rectangular shape is 0.0024um2
rect_M1B = RECTANGLE M1B
AREA rect_M1B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_M1028A{
@ RULE_M1028A
@ M1A min area for non-rectangular shape is 0.0036um2
no_rect_M1A = NOT RECTANGLE M1A
AREA no_rect_M1A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_M1028B{
@ RULE_M1028B
@ M1B min area for non-rectangular shape is 0.0036um2
no_rect_M1B = NOT RECTANGLE M1B
AREA no_rect_M1B < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V1001a{
@ RULE_V1001a
@ V1 is a square with 28nm edge length
RECTANGLE V1 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V1001b{
@ RULE_V1001b
@ V1 is a rectangle 28nm x 56nm when enclosed in M1A with width >= 60nm
wide_M1A = M1A WITH WIDTH >= 0.060
V1_wide_M1A = V1 INSIDE wide_M1A
RECTANGLE V1_wide_M1A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1001c{
@ RULE_V1001c
@ V1 is a rectangle 28nm x 56nm when enclosed in M1B with width >= 60nm
wide_M1B = M1B WITH WIDTH >= 0.060
V1_wide_M1B = V1 INSIDE wide_M1B
RECTANGLE V1_wide_M1B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V1001d{
@ RULE_V1001d
@ V1 is a rectangle 28nm x 56nm when enclosed in MINT1A with width >= 60nm
wide_MINT1A = MINT1A WITH WIDTH >= 0.060
V1_wide_MINT1A = V1 INSIDE wide_MINT1A
RECTANGLE V1_wide_MINT1A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1001e{
@ RULE_V1001e
@ V1 is a rectangle 28nm x 56nm when enclosed in MINT1B with width >= 60nm
wide_MINT1B = MINT1B WITH WIDTH >= 0.060
V1_wide_MINT1B = V1 INSIDE wide_MINT1B
RECTANGLE V1_wide_MINT1B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1002A{
 @ RULE_V1002A
 @ Minimum spacing of V1 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 M1A_MINT1A = M1A AND MINT1A
 // deriving edges of the intersection
 M1A_MINT1A_EDGES = ANGLE M1A_MINT1A == 90
 // identifying edges with runlength = 28nm
 M1A_MINT1A_EDGES_LENGTH = PATH LENGTH M1A_MINT1A_EDGES == 0.028
 // forming polygons out of those edges
 M1A_MINT1A_polygons = M1A WITH EDGE M1A_MINT1A_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 V1_M1A_MINT1A = V1 INTERACT M1A_MINT1A_polygons
 // Finding spacing
 EXT V1_M1A_MINT1A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1002B{
 @ RULE_V1002B
 @ Minimum spacing of V1 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 M1B_MINT1B = M1B AND MINT1B
 // deriving edges of the intersection
 M1B_MINT1B_EDGES = ANGLE M1B_MINT1B == 90
 // identifying edges with runlength = 28nm
 M1B_MINT1B_EDGES_LENGTH = PATH LENGTH M1B_MINT1B_EDGES == 0.028
 // forming polygons out of those edges
 M1B_MINT1B_polygons = M1B WITH EDGE M1B_MINT1B_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 V1_M1B_MINT1B = V1 INTERACT M1B_MINT1B_polygons
 // Finding spacing
 EXT V1_M1B_MINT1B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1003A{
 @ RULE_V1003A
 @ Minimum spacing of V1 if runlength < 28nm is 50nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 M1A_MINT1A = M1A AND MINT1A
 // deriving edges of the intersection
 M1A_MINT1A_EDGES = ANGLE M1A_MINT1A == 90
 // identifying edges with runlength < 28nm
 M1A_MINT1A_EDGES_LENGTH = PATH LENGTH M1A_MINT1A_EDGES < 0.028
 // forming polygons out of those edges
 M1A_MINT1A_polygons = M1A WITH EDGE M1A_MINT1A_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 V1_M1A_MINT1A = V1 INTERACT M1A_MINT1A_polygons
 // Finding spacing
 EXT V1_M1A_MINT1A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1003B{
 @ RULE_V1003B
 @ Minimum spacing of V1 if runlength < 28nm is 50nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 M1B_MINT1B = M1B AND MINT1B
 // deriving edges of the intersection
 M1B_MINT1B_EDGES = ANGLE M1B_MINT1B == 90
 // identifying edges with runlength = 28nm
 M1B_MINT1B_EDGES_LENGTH = PATH LENGTH M1B_MINT1B_EDGES < 0.028
 // forming polygons out of those edges
 M1B_MINT1B_polygons = M1B WITH EDGE M1B_MINT1B_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 V1_M1B_MINT1B = V1 INTERACT M1B_MINT1B_polygons
 // Finding spacing
 EXT V1_M1B_MINT1B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V1004{
@ RULE_V1004
@ V1 must be inside (M1A and MINT1A) or (M1B and MINT1B) or (M1A and MINT1B) or (M1B and MINT1A)
layer_intersections = OR (M1A AND MINT1A) (M1B AND MINT1B) (M1A AND MINT1B) (M1B AND MINT1A)
V1 OUTSIDE layer_intersections
}
///////////////////////////////////////////////////////////////////////////////////
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn1026B as V1005A and V1005B
/////////////////////////////////////////////////////////////////////////////////
RULE_V1005A{
@ RULE_V1005A
@ V1 shape must be rectangular if enclosing M1A wire width >= 60nm
wide_M1A = M1A WITH WIDTH >= 0.060
V1_in_wideM1A = V1 INSIDE wide_M1A
NOT RECTANGLE V1_in_wideM1A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V1005B{
@ RULE_V1005B
@ V1 shape must be rectangular if enclosing M1B wire width >= 60nm
wide_M1B = M1B WITH WIDTH >= 0.060
V1_in_wideM1B = V1 INSIDE wide_M1B
NOT RECTANGLE V1_in_wideM1B
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V2001a{
@ RULE_V2001a
@ V2 is a square with 28nm edge length
RECTANGLE V2 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V2001b{
@ RULE_V2001b
@ V2 is a rectangle 28nm x 56nm when enclosed in MINT1A with width >= 60nm
wide_MINT1A = MINT1A WITH WIDTH >= 0.060
V2_wide_MINT1A = V2 INSIDE wide_MINT1A
RECTANGLE V2_wide_MINT1A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2001c{
@ RULE_V2001c
@ V2 is a rectangle 28nm x 56nm when enclosed in MINT1B with width >= 60nm
wide_MINT1B = MINT1B WITH WIDTH >= 0.060
V2_wide_MINT1B = V2 INSIDE wide_MINT1B
RECTANGLE V2_wide_MINT1B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V2001d{
@ RULE_V2001d
@ V2 is a rectangle 28nm x 56nm when enclosed in MINT2A with width >= 60nm
wide_MINT2A = MINT2A WITH WIDTH >= 0.060
V2_wide_MINT2A = V2 INSIDE wide_MINT2A
RECTANGLE V2_wide_MINT2A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2001e{
@ RULE_V2001e
@ V2 is a rectangle 28nm x 56nm when enclosed in MINT2B with width >= 60nm
wide_MINT2B = MINT2B WITH WIDTH >= 0.060
V2_wide_MINT2B = V2 INSIDE wide_MINT2B
RECTANGLE V2_wide_MINT2B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2002A{
 @ RULE_V2002A
 @ Minimum spacing of V2 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT1 and MINT2, and MINT1 is vertical 
 MINT1A_MINT2A = MINT1A AND MINT2A
 // deriving edges of the intersection
 MINT1A_MINT2A_EDGES = ANGLE MINT1A_MINT2A == 90
 // identifying edges with runlength = 28nm
 MINT1A_MINT2A_EDGES_LENGTH = PATH LENGTH MINT1A_MINT2A_EDGES == 0.028
 // forming polygons out of those edges
 MINT1A_MINT2A_polygons = MINT1A WITH EDGE MINT1A_MINT2A_EDGES_LENGTH
 // finding V2 that interact with the formed polygons
 V2_MINT1A_MINT2A = V2 INTERACT MINT1A_MINT2A_polygons
 // Finding spacing
 EXT V2_MINT1A_MINT2A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2002B{
 @ RULE_V2002B
 @ Minimum spacing of V2 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT1 and MINT2, and MINT1 is vertical 
 MINT1B_MINT2B = MINT1B AND MINT2B
 // deriving edges of the intersection
 MINT1B_MINT2B_EDGES = ANGLE MINT1B_MINT2B == 90
 // identifying edges with runlength = 28nm
 MINT1B_MINT2B_EDGES_LENGTH = PATH LENGTH MINT1B_MINT2B_EDGES == 0.028
 // forming polygons out of those edges
 MINT1B_MINT2B_polygons = MINT1B WITH EDGE MINT1B_MINT2B_EDGES_LENGTH
 // finding V2 that interact with the formed polygons
 V2_MINT1B_MINT2B = V2 INTERACT MINT1B_MINT2B_polygons
 // Finding spacing
 EXT V2_MINT1B_MINT2B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2003A{
 @ RULE_V2003A
 @ Minimum spacing of V2 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT1 and MINT2, and MINT1 is vertical 
 MINT1A_MINT2A = MINT1A AND MINT2A
 // deriving edges of the intersection
 MINT1A_MINT2A_EDGES = ANGLE MINT1A_MINT2A == 90
 // identifying edges with runlength < 28nm
 MINT1A_MINT2A_EDGES_LENGTH = PATH LENGTH MINT1A_MINT2A_EDGES < 0.028
 // forming polygons out of those edges
 MINT1A_MINT2A_polygons = MINT1A WITH EDGE MINT1A_MINT2A_EDGES_LENGTH
 // finding V2 that interact with the formed polygons
 V2_MINT1A_MINT2A = V2 INTERACT MINT1A_MINT2A_polygons
 // Finding spacing
 EXT V2_MINT1A_MINT2A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2003B{
 @ RULE_V2003B
 @ Minimum spacing of V2 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT1 and MINT2, and MINT1 is vertical 
 MINT1B_MINT2B = MINT1B AND MINT2B
 // deriving edges of the intersection
 MINT1B_MINT2B_EDGES = ANGLE MINT1B_MINT2B == 90
 // identifying edges with runlength = 28nm
 MINT1B_MINT2B_EDGES_LENGTH = PATH LENGTH MINT1B_MINT2B_EDGES < 0.028
 // forming polygons out of those edges
 MINT1B_MINT2B_polygons = MINT1B WITH EDGE MINT1B_MINT2B_EDGES_LENGTH
 // finding V2 that interact with the formed polygons
 V2_MINT1B_MINT2B = V2 INTERACT MINT1B_MINT2B_polygons
 // Finding spacing
 EXT V2_MINT1B_MINT2B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V2004{
@ RULE_V2004
@ V2 must be inside (MINT1A and MINT2A) or (MINT1B and MINT2B) or (MINT1A and MINT2B) or (MINT1B and MINT2A)
layer_intersections = OR (MINT1A AND MINT2A) (MINT1B AND MINT2B) (MINT1A AND MINT2B) (MINT1B AND MINT2A)
V2 OUTSIDE layer_intersections
}
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn026B as Vn005A and Vn005B
/////////////////////////////////////////////////////////////////////////////////
RULE_V2005A{
@ RULE_V2005A
@ V2 shape must be rectangular if enclosing MINT1A wire width >= 60nm
wide_MINT1A = MINT1A WITH WIDTH >= 0.060
V2_in_wideMINT1A = V2 INSIDE wide_MINT1A
NOT RECTANGLE V2_in_wideMINT1A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V2005B{
@ RULE_V2005B
@ V2 shape must be rectangular if enclosing MINT1B wire width >= 60nm
wide_MINT1B = MINT1B WITH WIDTH >= 0.060
V2_in_wideMINT1B = V2 INSIDE wide_MINT1B
NOT RECTANGLE V2_in_wideMINT1B
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V3 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V3001a{
@ RULE_V3001a
@ V3 is a square with 28nm edge length
RECTANGLE V3 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V3001b{
@ RULE_V3001b
@ V3 is a rectangle 28nm x 56nm when enclosed in MINT2A with width >= 60nm
wide_MINT2A = MINT2A WITH WIDTH >= 0.060
V3_wide_MINT2A = V3 INSIDE wide_MINT2A
RECTANGLE V3_wide_MINT2A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3001c{
@ RULE_V3001c
@ V3 is a rectangle 28nm x 56nm when enclosed in MINT2B with width >= 60nm
wide_MINT2B = MINT2B WITH WIDTH >= 0.060
V3_wide_MINT2B = V3 INSIDE wide_MINT2B
RECTANGLE V3_wide_MINT2B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V3001d{
@ RULE_V3001d
@ V3 is a rectangle 28nm x 56nm when enclosed in MINT3A with width >= 60nm
wide_MINT3A = MINT3A WITH WIDTH >= 0.060
V3_wide_MINT3A = V3 INSIDE wide_MINT3A
RECTANGLE V3_wide_MINT3A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3001e{
@ RULE_V3001e
@ V3 is a rectangle 28nm x 56nm when enclosed in MINT3B with width >= 60nm
wide_MINT3B = MINT3B WITH WIDTH >= 0.060
V3_wide_MINT3B = V3 INSIDE wide_MINT3B
RECTANGLE V3_wide_MINT3B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3002A{
 @ RULE_V3002A
 @ Minimum spacing of V3 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT2 and MINT3,  
 MINT2A_MINT3A = MINT2A AND MINT3A
 // deriving edges of the intersection
 MINT2A_MINT3A_EDGES = ANGLE MINT2A_MINT3A == 90
 // identifying edges with runlength = 28nm
 MINT2A_MINT3A_EDGES_LENGTH = PATH LENGTH MINT2A_MINT3A_EDGES == 0.028
 // forming polygons out of those edges
 MINT2A_MINT3A_polygons = MINT2A WITH EDGE MINT2A_MINT3A_EDGES_LENGTH
 // finding V3 that interact with the formed polygons
 V3_MINT2A_MINT3A = V3 INTERACT MINT2A_MINT3A_polygons
 // Finding spacing
 EXT V3_MINT2A_MINT3A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3002B{
 @ RULE_V3002B
 @ Minimum spacing of V3 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT2 and MINT3, 
 MINT2B_MINT3B = MINT2B AND MINT3B
 // deriving edges of the intersection
 MINT2B_MINT3B_EDGES = ANGLE MINT2B_MINT3B == 90
 // identifying edges with runlength = 28nm
 MINT2B_MINT3B_EDGES_LENGTH = PATH LENGTH MINT2B_MINT3B_EDGES == 0.028
 // forming polygons out of those edges
 MINT2B_MINT3B_polygons = MINT2B WITH EDGE MINT2B_MINT3B_EDGES_LENGTH
 // finding V3 that interact with the formed polygons
 V3_MINT2B_MINT3B = V3 INTERACT MINT2B_MINT3B_polygons
 // Finding spacing
 EXT V3_MINT2B_MINT3B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3003A{
 @ RULE_V3003A
 @ Minimum spacing of V3 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT2 and MINT3, 
 MINT2A_MINT3A = MINT2A AND MINT3A
 // deriving edges of the intersection
 MINT2A_MINT3A_EDGES = ANGLE MINT2A_MINT3A == 90
 // identifying edges with runlength < 28nm
 MINT2A_MINT3A_EDGES_LENGTH = PATH LENGTH MINT2A_MINT3A_EDGES < 0.028
 // forming polygons out of those edges
 MINT2A_MINT3A_polygons = MINT2A WITH EDGE MINT2A_MINT3A_EDGES_LENGTH
 // finding V3 that interact with the formed polygons
 V3_MINT2A_MINT3A = V3 INTERACT MINT2A_MINT3A_polygons
 // Finding spacing
 EXT V3_MINT2A_MINT3A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3003B{
 @ RULE_V3003B
 @ Minimum spacing of V3 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT2 and MINT3, 
 MINT2B_MINT3B = MINT2B AND MINT3B
 // deriving edges of the intersection
 MINT2B_MINT3B_EDGES = ANGLE MINT2B_MINT3B == 90
 // identifying edges with runlength = 28nm
 MINT2B_MINT3B_EDGES_LENGTH = PATH LENGTH MINT2B_MINT3B_EDGES < 0.028
 // forming polygons out of those edges
 MINT2B_MINT3B_polygons = MINT2B WITH EDGE MINT2B_MINT3B_EDGES_LENGTH
 // finding V3 that interact with the formed polygons
 V3_MINT2B_MINT3B = V3 INTERACT MINT2B_MINT3B_polygons
 // Finding spacing
 EXT V3_MINT2B_MINT3B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V3004{
@ RULE_V3004
@ V3 must be inside (MINT2A and MINT3A) or (MINT2B and MINT3B) or (MINT2A and MINT3B) or (MINT2B and MINT3A)
layer_intersections = OR (MINT2A AND MINT3A) (MINT2B AND MINT3B) (MINT2A AND MINT3B) (MINT2B AND MINT3A)
V3 OUTSIDE layer_intersections
}
///////////////////////////////////////////////////////////////////////////////////
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn1026B as V1005A and V1005B
/////////////////////////////////////////////////////////////////////////////////
RULE_V3005A{
@ RULE_V3005A
@ V3 shape must be rectangular if enclosing MINT2A wire width >= 60nm
wide_MINT2A = MINT2A WITH WIDTH >= 0.060
V3_in_wideMINT2A = V3 INSIDE wide_MINT2A
NOT RECTANGLE V3_in_wideMINT2A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V3005B{
@ RULE_V3005B
@ V3 shape must be rectangular if enclosing MINT2B wire width >= 40nm
wide_MINT2B = MINT2B WITH WIDTH >= 0.060
V3_in_wideMINT2B = V3 INSIDE wide_MINT2B
NOT RECTANGLE V3_in_wideMINT2B
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V4 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V4001a{
@ RULE_V4001a
@ V4 is a square with 28nm edge length
RECTANGLE V4 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V4001b{
@ RULE_V4001b
@ V4 is a rectangle 28nm x 56nm when enclosed in MINT3A with width >= 60nm
wide_MINT3A = MINT3A WITH WIDTH >= 0.060
V4_wide_MINT3A = V4 INSIDE wide_MINT3A
RECTANGLE V4_wide_MINT3A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4001c{
@ RULE_V4001c
@ V4 is a rectangle 28nm x 56nm when enclosed in MINT3B with width >= 60nm
wide_MINT3B = MINT3B WITH WIDTH >= 0.060
V4_wide_MINT3B = V4 INSIDE wide_MINT3B
RECTANGLE V4_wide_MINT3B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V4001d{
@ RULE_V4001d
@ V4 is a rectangle 28nm x 56nm when enclosed in MINT4A with width >= 60nm
wide_MINT4A = MINT4A WITH WIDTH >= 0.060
V4_wide_MINT4A = V4 INSIDE wide_MINT4A
RECTANGLE V4_wide_MINT4A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4001e{
@ RULE_V4001e
@ V4 is a rectangle 28nm x 56nm when enclosed in MINT4B with width >= 60nm
wide_MINT4B = MINT4B WITH WIDTH >= 0.060
V4_wide_MINT4B = V4 INSIDE wide_MINT4B
RECTANGLE V4_wide_MINT4B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4002A{
 @ RULE_V4002A
 @ Minimum spacing of V4 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT3 and MINT4,  
 MINT3A_MINT4A = MINT3A AND MINT4A
 // deriving edges of the intersection
 MINT3A_MINT4A_EDGES = ANGLE MINT3A_MINT4A == 90
 // identifying edges with runlength = 28nm
 MINT3A_MINT4A_EDGES_LENGTH = PATH LENGTH MINT3A_MINT4A_EDGES == 0.028
 // forming polygons out of those edges
 MINT3A_MINT4A_polygons = MINT3A WITH EDGE MINT3A_MINT4A_EDGES_LENGTH
 // finding V4 that interact with the formed polygons
 V4_MINT3A_MINT4A = V4 INTERACT MINT3A_MINT4A_polygons
 // Finding spacing
 EXT V4_MINT3A_MINT4A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4002B{
 @ RULE_V4002B
 @ Minimum spacing of V4 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT3 and MINT4, 
 MINT3B_MINT4B = MINT3B AND MINT4B
 // deriving edges of the intersection
 MINT3B_MINT4B_EDGES = ANGLE MINT3B_MINT4B == 90
 // identifying edges with runlength = 28nm
 MINT3B_MINT4B_EDGES_LENGTH = PATH LENGTH MINT3B_MINT4B_EDGES == 0.028
 // forming polygons out of those edges
 MINT3B_MINT4B_polygons = MINT3B WITH EDGE MINT3B_MINT4B_EDGES_LENGTH
 // finding V4 that interact with the formed polygons
 V4_MINT3B_MINT4B = V4 INTERACT MINT3B_MINT4B_polygons
 // Finding spacing
 EXT V4_MINT3B_MINT4B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4003A{
 @ RULE_V4003A
 @ Minimum spacing of V4 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT3 and MINT4, 
 MINT3A_MINT4A = MINT3A AND MINT4A
 // deriving edges of the intersection
 MINT3A_MINT4A_EDGES = ANGLE MINT3A_MINT4A == 90
 // identifying edges with runlength < 28nm
 MINT3A_MINT4A_EDGES_LENGTH = PATH LENGTH MINT3A_MINT4A_EDGES < 0.028
 // forming polygons out of those edges
 MINT3A_MINT4A_polygons = MINT3A WITH EDGE MINT3A_MINT4A_EDGES_LENGTH
 // finding V4 that interact with the formed polygons
 V4_MINT3A_MINT4A = V4 INTERACT MINT3A_MINT4A_polygons
 // Finding spacing
 EXT V4_MINT3A_MINT4A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4003B{
 @ RULE_V4003B
 @ Minimum spacing of V4 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT3 and MINT4, 
 MINT3B_MINT4B = MINT3B AND MINT4B
 // deriving edges of the intersection
 MINT3B_MINT4B_EDGES = ANGLE MINT3B_MINT4B == 90
 // identifying edges with runlength = 28nm
 MINT3B_MINT4B_EDGES_LENGTH = PATH LENGTH MINT3B_MINT4B_EDGES < 0.028
 // forming polygons out of those edges
 MINT3B_MINT4B_polygons = MINT3B WITH EDGE MINT3B_MINT4B_EDGES_LENGTH
 // finding V4 that interact with the formed polygons
 V4_MINT3B_MINT4B = V4 INTERACT MINT3B_MINT4B_polygons
 // Finding spacing
 EXT V4_MINT3B_MINT4B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V4004{
@ RULE_V4004
@ V4 must be inside (MINT3A and MINT4A) or (MINT3B and MINT4B) or (MINT3A and MINT4B) or (MINT3B and MINT4A)
layer_intersections = OR (MINT3A AND MINT4A) (MINT3B AND MINT4B) (MINT3A AND MINT4B) (MINT3B AND MINT4A)
V4 OUTSIDE layer_intersections
}
///////////////////////////////////////////////////////////////////////////////////
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn1026B as V1005A and V1005B
////////////////////////////////////////////////////////////////////////////////
RULE_V4005A{
@ RULE_V4005A
@ V4 shape must be rectangular if enclosing MINT3A wire width >= 60nm
wide_MINT3A = MINT3A WITH WIDTH >= 0.060
V4_in_wideMINT3A = V4 INSIDE wide_MINT3A
NOT RECTANGLE V4_in_wideMINT3A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V4005B{
@ RULE_V4005B
@ V4 shape must be rectangular if enclosing MINT3B wire width >= 60nm
wide_MINT3B = MINT3B WITH WIDTH >= 0.060
V4_in_wideMINT3B = V4 INSIDE wide_MINT3B
NOT RECTANGLE V4_in_wideMINT3B
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V5 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V5001a{
@ RULE_V5001a
@ V5 is a square with 28nm edge length
RECTANGLE V5 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V5001b{
@ RULE_V5001b
@ V5 is a rectangle 28nm x 56nm when enclosed in MINT4A with width >= 60nm
wide_MINT4A = MINT4A WITH WIDTH >= 0.060
V5_wide_MINT4A = V5 INSIDE wide_MINT4A
RECTANGLE V5_wide_MINT4A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5001c{
@ RULE_V5001c
@ V5 is a rectangle 28nm x 56nm when enclosed in MINT4B with width >= 60nm
wide_MINT4B = MINT4B WITH WIDTH >= 0.060
V5_wide_MINT4B = V5 INSIDE wide_MINT4B
RECTANGLE V5_wide_MINT4B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V5001d{
@ RULE_V5001d
@ V5 is a rectangle 28nm x 56nm when enclosed in MINT5A with width >= 60nm
wide_MINT5A = MINT5A WITH WIDTH >= 0.060
V5_wide_MINT5A = V5 INSIDE wide_MINT5A
RECTANGLE V5_wide_MINT5A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5001e{
@ RULE_V5001e
@ V5 is a rectangle 28nm x 56nm when enclosed in MINT5B with width >= 60nm
wide_MINT5B = MINT5B WITH WIDTH >= 0.060
V5_wide_MINT5B = V5 INSIDE wide_MINT5B
RECTANGLE V5_wide_MINT5B != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5002A{
 @ RULE_V5002A
 @ Minimum spacing of V5 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT4 and MINT5,  
 MINT4A_MINT5A = MINT4A AND MINT5A
 // deriving edges of the intersection
 MINT4A_MINT5A_EDGES = ANGLE MINT4A_MINT5A == 90
 // identifying edges with runlength = 28nm
 MINT4A_MINT5A_EDGES_LENGTH = PATH LENGTH MINT4A_MINT5A_EDGES == 0.028
 // forming polygons out of those edges
 MINT4A_MINT5A_polygons = MINT4A WITH EDGE MINT4A_MINT5A_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V5_MINT4A_MINT5A = V5 INTERACT MINT4A_MINT5A_polygons
 // Finding spacing
 EXT V5_MINT4A_MINT5A < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5002B{
 @ RULE_V5002B
 @ Minimum spacing of V5 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT4B_MINT5B = MINT4B AND MINT5B
 // deriving edges of the intersection
 MINT4B_MINT5B_EDGES = ANGLE MINT4B_MINT5B == 90
 // identifying edges with runlength = 28nm
 MINT4B_MINT5B_EDGES_LENGTH = PATH LENGTH MINT4B_MINT5B_EDGES == 0.028
 // forming polygons out of those edges
 MINT4B_MINT5B_polygons = MINT4B WITH EDGE MINT4B_MINT5B_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V5_MINT4B_MINT5B = V5 INTERACT MINT4B_MINT5B_polygons
 // Finding spacing
 EXT V5_MINT4B_MINT5B < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5003A{
 @ RULE_V5003A
 @ Minimum spacing of V5 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT4A_MINT5A = MINT4A AND MINT5A
 // deriving edges of the intersection
 MINT4A_MINT5A_EDGES = ANGLE MINT4A_MINT5A == 90
 // identifying edges with runlength < 28nm
 MINT4A_MINT5A_EDGES_LENGTH = PATH LENGTH MINT4A_MINT5A_EDGES < 0.028
 // forming polygons out of those edges
 MINT4A_MINT5A_polygons = MINT4A WITH EDGE MINT4A_MINT5A_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V5_MINT4A_MINT5A = V5 INTERACT MINT4A_MINT5A_polygons
 // Finding spacing
 EXT V5_MINT4A_MINT5A < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5003B{
 @ RULE_V5003B
 @ Minimum spacing of V5 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT4B_MINT5B = MINT4B AND MINT5B
 // deriving edges of the intersection
 MINT4B_MINT5B_EDGES = ANGLE MINT4B_MINT5B == 90
 // identifying edges with runlength = 28nm
 MINT4B_MINT5B_EDGES_LENGTH = PATH LENGTH MINT4B_MINT5B_EDGES < 0.028
 // forming polygons out of those edges
 MINT4B_MINT5B_polygons = MINT4B WITH EDGE MINT4B_MINT5B_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V5_MINT4B_MINT5B = V5 INTERACT MINT4B_MINT5B_polygons
 // Finding spacing
 EXT V5_MINT4B_MINT5B < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V5004{
@ RULE_V5004
@ V5 must be inside (MINT4A and MINT5A) or (MINT4B and MINT5B) or (MINT4A and MINT5B) or (MINT4B and MINT5A)
layer_intersections = OR (MINT4A AND MINT5A) (MINT4B AND MINT5B) (MINT4A AND MINT5B) (MINT4B AND MINT5A)
V5 OUTSIDE layer_intersections
}
///////////////////////////////////////////////////////////////////////////////////
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn1026B as V5005A and V5005B
////////////////////////////////////////////////////////////////////////////////
RULE_V5005A{
@ RULE_V5005A
@ V5 shape must be rectangular if enclosing MINT4A wire width >= 60nm
wide_MINT4A = MINT4A WITH WIDTH >= 0.060
V5_in_wideMINT4A = V5 INSIDE wide_MINT4A
NOT RECTANGLE V5_in_wideMINT4A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V5005B{
@ RULE_V5005B
@ V5 shape must be rectangular if enclosing MINT4B wire width >= 60nm
wide_MINT4B = MINT4B WITH WIDTH >= 0.060
V5_in_wideMINT4B = V5 INSIDE wide_MINT4B
NOT RECTANGLE V5_in_wideMINT4B
}
////////////////////////////////////////////////////////////////////////////////////
//_________________________________________________________________________ V6 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_V6001a{
@ RULE_V6001a
@ V6 is a square with 28nm edge length
RECTANGLE V6 != 0.028 BY != 0.028 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V6001b{
@ RULE_V6001b
@ V6 is a rectangle 28nm x 56nm when enclosed in MINT5A with width >= 60nm
wide_MINT5A = MINT5A WITH WIDTH >= 0.060
V6_wide_MINT5A = V6 INSIDE wide_MINT5A
RECTANGLE V6_wide_MINT5A != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6001c{
@ RULE_V6001c
@ V6 is a rectangle 28nm x 56nm when enclosed in MINT5B with width >= 60nm
wide_MINT5B = MINT5B WITH WIDTH >= 0.060
V6_wide_MINT5B = V6 INSIDE wide_MINT5B
RECTANGLE V6_wide_MINT5B != 0.056 BY != 0.028
}
///////////////////////////////////////////////////////////////////////////////////
RULE_V6001d{
@ RULE_V6001d
@ V6 is a rectangle 28nm x 56nm when enclosed in MSMG1 with width >= 60nm
wide_MSMG1 = MSMG1 WITH WIDTH >= 0.060
V6_wide_MSMG1 = V6 INSIDE wide_MSMG1
RECTANGLE V6_wide_MSMG1 != 0.056 BY != 0.028
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6002A{
 @ RULE_V6002A
 @ Minimum spacing of V6 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT4 and MINT5,  
 MINT5A_MSMG1 = MINT5A AND MSMG1
 // deriving edges of the intersection
 MINT5A_MSMG1_EDGES = ANGLE MINT5A_MSMG1 == 90
 // identifying edges with runlength = 28nm
 MINT5A_MSMG1_EDGES_LENGTH = PATH LENGTH MINT5A_MSMG1_EDGES == 0.028
 // forming polygons out of those edges
 MINT5A_MSMG1_polygons = MINT5A WITH EDGE MINT5A_MSMG1_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V6_MINT5A_MSMG1 = V6 INTERACT MINT5A_MSMG1_polygons
 // Finding spacing
 EXT V6_MINT5A_MSMG1 < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6002B{
 @ RULE_V6002B
 @ Minimum spacing of V6 if runlength exactly = 28nm is 36nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT5B_MSMG1 = MINT5B AND MSMG1
 // deriving edges of the intersection
 MINT5B_MSMG1_EDGES = ANGLE MINT5B_MSMG1 == 90
 // identifying edges with runlength = 28nm
 MINT5B_MSMG1_EDGES_LENGTH = PATH LENGTH MINT5B_MSMG1_EDGES == 0.028
 // forming polygons out of those edges
 MINT5B_MSMG1_polygons = MINT5B WITH EDGE MINT5B_MSMG1_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V6_MINT5B_MSMG1 = V6 INTERACT MINT5B_MSMG1_polygons
 // Finding spacing
 EXT V6_MINT5B_MSMG1 < 0.036
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6003A{
 @ RULE_V6003A
 @ Minimum spacing of V6 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT5A_MSMG1 = MINT5A AND MSMG1
 // deriving edges of the intersection
 MINT5A_MSMG1_EDGES = ANGLE MINT5A_MSMG1 == 90
 // identifying edges with runlength < 28nm
 MINT5A_MSMG1_EDGES_LENGTH = PATH LENGTH MINT5A_MSMG1_EDGES < 0.028
 // forming polygons out of those edges
 MINT5A_MSMG1_polygons = MINT5A WITH EDGE MINT5A_MSMG1_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V6_MINT5A_MSMG1 = V6 INTERACT MINT5A_MSMG1_polygons
 // Finding spacing
 EXT V6_MINT5A_MSMG1 < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6003B{
 @ RULE_V6003B
 @ Minimum spacing of V6 if runlength < 28nm is 50nm
 // assuming runlength is the common length between MINT4 and MINT5, 
 MINT5B_MSMG1 = MINT5B AND MSMG1
 // deriving edges of the intersection
 MINT5B_MSMG1_EDGES = ANGLE MINT5B_MSMG1 == 90
 // identifying edges with runlength = 28nm
 MINT5B_MSMG1_EDGES_LENGTH = PATH LENGTH MINT5B_MSMG1_EDGES < 0.028
 // forming polygons out of those edges
 MINT5B_MSMG1_polygons = MINT5B WITH EDGE MINT5B_MSMG1_EDGES_LENGTH
 // finding V5 that interact with the formed polygons
 V6_MINT5B_MSMG1 = V6 INTERACT MINT5B_MSMG1_polygons
 // Finding spacing
 EXT V6_MINT5B_MSMG1 < 0.050
}
////////////////////////////////////////////////////////////////////////////////////
RULE_V6004{
@ RULE_V6004
@ V6 must be inside (MINT5A and MSMG1) or (MINT5B and MSMG1)
layer_intersections = OR (MINT5A AND MSMG1) (MINT5B AND MSMG1)
V6 OUTSIDE layer_intersections
}
///////////////////////////////////////////////////////////////////////////////////
//XXX Removed Vn023 and Vn024 and renamed Vn026A and Vn1026B as V6005A and V6005B
////////////////////////////////////////////////////////////////////////////////
RULE_V6005A{
@ RULE_V6005A
@ V6 shape must be rectangular if enclosing MINT5A wire width >= 60nm
wide_MINT5A = MINT5A WITH WIDTH >= 0.060
V6_in_wideMINT5A = V6 INSIDE wide_MINT5A
NOT RECTANGLE V6_in_wideMINT5A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_V6005B{
@ RULE_V6005B
@ V6 shape must be rectangular if enclosing MINT5B wire width >= 60nm
wide_MINT5B = MINT5B WITH WIDTH >= 0.060
V6_in_wideMINT5B = V6 INSIDE wide_MINT5B
NOT RECTANGLE V6_in_wideMINT5B
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MINT1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MINT1001A{
@ RULE_MINT1001B
@ MINT1A width > 28nm
INTERNAL MINT1A < 0.028 
}
//XXX INTERNAL MINT1A < 0.028 
//INTERNAL MINT1A > 0.028 < 0.032
//INTERNAL MINT1A > 0.032 < 0.040
//INTERNAL MINT1A > 0.040 < 2.400
//INTERNAL MINT1A > 2.4 < 10
//} changed to INTERNAL MINT1A < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT1001B{
@ RULE_MINT1001B
@ MINT1A width > 28nm
INTERNAL MINT1B < 0.028 
}
//XXX INTERNAL MINT1B < 0.028 
//INTERNAL MINT1B > 0.028 < 0.032
//INTERNAL MINT1B > 0.032 < 0.040
//INTERNAL MINT1B > 0.040 < 2.400
//INTERNAL MINT1B > 2.4 < 10
//} changed to INTERNAL MINT1B < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT1002A{
@ RULE_MINT1002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT1A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1002B{
@ RULE_MINT1002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT1B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1003A{
@ RULE_MINT1003A
@ maximum length of MINT1A for wires with min width 28nm is 960nm
wide_MINT1A = MINT1A with width <= 0.028
d = INT wide_MINT1A <= 1 opposite
d_p = dfm property wide_MINT1A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1003B{
@ RULE_MINT1003B
@ maximum length of MINT1B for wires with min width 28nm is 960nm
wide_MINT1B = MINT1B with width <= 0.028
d = INT wide_MINT1B <= 1 opposite
d_p = dfm property wide_MINT1B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1004A{
@ RULE_MINT1004A
@ MINT1A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT1A_eol = LENGTH MINT1A < 0.032
EXT MINT1A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1004B{
@ RULE_MINT1004B
@ MINT1B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT1B_eol = LENGTH MINT1B < 0.032
EXT MINT1B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1005A{
@ RULE_MINT1005A
@ MINT1A min space and notch 54nm
EXT MINT1A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1005B{
@ RULE_MINT1005B
@ MINT1B min space and notch 54nm
EXT MINT1B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT1006{
@ RULE_MINT1006
@ min spacing of MINT1A to MINT1B 36nm
EXT MINT1A MINT1B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1007{
@ RULE_MINT1007
@ End-of-line spacing of MINT1A to MINT1B (EOL edge defined as edge < 32nm) is 44nm
MINT1A_eol = LENGTH MINT1A < 0.032
MINT1B_eol = LENGTH MINT1B < 0.032
EXT MINT1A_eol MINT1B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1008A{
@ RULE_MINT1008A
@ Minimum spacing of MINT1A when MINT1A is wider than 32nm and longer than 240nm is 68nm
MINT1A_wide = MINT1A WITH WIDTH > 0.032
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1008B{
@ RULE_MINT1008B
@ Minimum spacing of MINT1B when MINT1B is wider than 32nm and longer than 240nm is 68nm
MINT1B_wide = MINT1B WITH WIDTH > 0.032
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1009A{
@ RULE_MINT1009A
@ Minimum spacing of MINT1A when MINT1A is wider than 40nm and longer than 240nm is 76nm
MINT1A_wide = MINT1A WITH WIDTH > 0.040
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1009B{
@ RULE_MINT1009B
@ Minimum spacing of MINT1B when MINT1B is wider than 40nm and longer than 240nm is 76nm
MINT1B_wide = MINT1B WITH WIDTH > 0.040
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1010A{
@ RULE_MINT1010A
@ Minimum spacing of MINT1A when MINT1A is wider than 64nm and longer than 480nm is 92nm
MINT1A_wide = MINT1A WITH WIDTH > 0.064
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT1A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1010B{
@ RULE_MINT1010B
@ Minimum spacing of MINT1B when MINT1B is wider than 64nm and longer than 480nm is 92nm
MINT1B_wide = MINT1B WITH WIDTH > 0.064
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT1B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1011A{
@ RULE_MINT1011A
@ Minimum spacing of MINT1A when MINT1A is wider than 120nm and longer than 1200nm is 120nm
MINT1A_wide = MINT1A WITH WIDTH > 0.120
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT1A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1011B{
@ RULE_MINT1011B
@ Minimum spacing of MINT1B when MINT1B is wider than 120nm and longer than 1200nm is 120nm
MINT1B_wide = MINT1B WITH WIDTH > 0.120
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT1B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1012A{
@ RULE_MINT1012A
@ Minimum spacing of MINT1A when MINT1A is wider than 240nm and longer than 1800nm is 240nm
MINT1A_wide = MINT1A WITH WIDTH > 0.240
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT1A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1012B{
@ RULE_MINT1012B
@ Minimum spacing of MINT1B when MINT1B is wider than 240nm and longer than 1800nm is 240nm
MINT1B_wide = MINT1B WITH WIDTH > 0.240
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT1B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1013A{
@ RULE_MINT1013A
@ Minimum spacing of MINT1A when MINT1A is wider than 320nm and longer than 2400nm is 320nm
MINT1A_wide = MINT1A WITH WIDTH > 0.320
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1013B{
@ RULE_MINT1013B
@ Minimum spacing of MINT1B when MINT1B is wider than 320nm and longer than 2400nm is 320nm
MINT1B_wide = MINT1B WITH WIDTH > 0.320
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1014A{
@ RULE_MINT1014A
@ Minimum spacing of MINT1A when MINT1A is wider than 600nm and longer than 2400nm is 600nm
MINT1A_wide = MINT1A WITH WIDTH > 0.600
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1014B{
@ RULE_MINT1014B
@ Minimum spacing of MINT1B when MINT1B is wider than 600nm and longer than 2400nm is 600nm
MINT1B_wide = MINT1B WITH WIDTH > 0.600
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1015A{
@ RULE_MINT1015A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 32nm and longer than 240nm is 44nm
MINT1B_wide = MINT1B WITH WIDTH > 0.032
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1015B{
@ RULE_MINT1015B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 32nm and longer than 240nm is 44nm
MINT1A_wide = MINT1A WITH WIDTH > 0.032
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1016A{
@ RULE_MINT1016A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 40nm and longer than 240nm is 50nm
MINT1B_wide = MINT1B WITH WIDTH > 0.040
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1016B{
@ RULE_MINT1016B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 40nm and longer than 240nm is 50nm
MINT1A_wide = MINT1A WITH WIDTH > 0.040
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT1B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1017A{
@ RULE_MINT1017A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 64nm and longer than 480nm is 60nm
MINT1B_wide = MINT1B WITH WIDTH > 0.064
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT1A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1017B{
@ RULE_MINT1017B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 64nm and longer than 480nm is 60nm
MINT1A_wide = MINT1A WITH WIDTH > 0.064
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT1B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1018A{
@ RULE_MINT1018A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 120nm and longer than 1200nm is 78nm
MINT1B_wide = MINT1B WITH WIDTH > 0.120
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT1A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1018B{
@ RULE_MINT1018B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 120nm and longer than 1200nm is 78nm
MINT1A_wide = MINT1A WITH WIDTH > 0.120
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT1B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1019A{
@ RULE_MINT1019A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 240nm and longer than 1800nm is 156nm
MINT1B_wide = MINT1B WITH WIDTH > 0.240
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT1A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1019B{
@ RULE_MINT1019B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 240nm and longer than 1800nm is 156nm
MINT1A_wide = MINT1A WITH WIDTH > 0.240
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT1B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1020A{
@ RULE_MINT1020A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 320nm and longer than 2400nm is 200nm
MINT1B_wide = MINT1B WITH WIDTH > 0.320
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1020B{
@ RULE_MINT1020B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 320nm and longer than 2400nm is 200nm
MINT1A_wide = MINT1A WITH WIDTH > 0.320
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1021A{
@ RULE_MINT1021A
@ Minimum spacing of MINT1A to MINT1B when MINT1B is wider than 600nm and longer than 2400nm is 400nm
MINT1B_wide = MINT1B WITH WIDTH > 0.600
d = INT MINT1B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1021B{
@ RULE_MINT1021B
@ Minimum spacing of MINT1B to MINT1A when MINT1A is wider than 600nm and longer than 2400nm is 400nm
MINT1A_wide = MINT1A WITH WIDTH > 0.600
d = INT MINT1A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT1A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT1B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1022{
@ RULE_MINT1022
@ Minimum overlap of MINT1A and MINT1B (stitch region length)
MINT1AB_stitch = MINT1A AND MINT1B
INT MINT1AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1023A{
@ RULE_MINT1023A
@ Allowed enclosures of V1 by MINT1A
RECTANGLE ENCLOSURE V1 MINT1A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
//XXX changed V0 to V1
/// XXX RECTANGLE ENCLOSURE V0 MINT1A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 MINT1A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1023B{
@ RULE_MINT1023B
@ Allowed enclosures of V1 by MINT1B
RECTANGLE ENCLOSURE V1 MINT1B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002 
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
///changed V0 to V1
/// XXX RECTANGLE ENCLOSURE V0 MINT1B ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 MINT1B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1024{
@ RULE_MINT1024
@ Allowed enclosures of V1 by MINT1A-MINT1B stitches
MINT1AB_stitch = MINT1A AND MINT1B
RECTANGLE ENCLOSURE V1 MINT1AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
/// XXX RECTANGLE ENCLOSURE V0 MINT1AB_stitch ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V0 MINT1Ab_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
///XXX changed V0 to V1
/////////////////////////////////////////////////////////////////////////////////
//RULE_MINT1025A{
//@ RULE_MINT1025A
//@ V1 center must be aligned to wire center (between 2 longest edges)
//V1_MINT1A_OVERLAP =  V1 AND MINT1A
//// deriving metal and via edge pairs
//MINT1A_edges = INT MINT1A < 1
//V1_edges = INT V1 < 1
//// deriving metal and via center lines
//MINT1A_centerline = DFM COPY MINT1A_edges CENTERLINE
//V1_centerline = DFM COPY V1_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT1A_centerline COIN EDGE V1_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V1_MINT1A_OVERLAP NOT INTERACT y
//}
//// XXX V1 NOT INTERACT y 
//// changed to V1_MINT1A_OVERLAP NOT INTERACT y 
//// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
///////////////////////////////////////////////////////////////////////////////////
//RULE_MINT1025B{
//@ RULE_MINT1025B
//@ V1 center must be aligned to wire center (between 2 longest edges)
//V1_MINT1B_OVERLAP = V1 AND MINT1B
//// deriving metal and via edge pairs
//MINT1B_edges = INT MINT1B < 1
//V1_edges = INT V1 < 1
//// deriving metal and via center lines
//MINT1B_centerline = DFM COPY MINT1B_edges CENTERLINE
//V1_centerline = DFM COPY V1_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT1B_centerline COIN EDGE V1_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V1_MINT1B_OVERLAP NOT INTERACT y
//}
// XXX V1 NOT INTERACT y 
// changed to V1_MINT1B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1026A{
@ RULE_MINT1026A
@ V1 shape must be rectangular if enclosing MINT1A wire width >= 60nm
wide_MINT1A = MINT1A WITH WIDTH >= 0.060
V1_in_wideMINT1A = V1 INSIDE wide_MINT1A
NOT RECTANGLE V1_in_wideMINT1A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1026B{
@ RULE_MINT1026B
@ V1 shape must be rectangular if enclosing MINT1B wire width >= 60nm
wide_MINT1B = MINT1B WITH WIDTH >= 0.060
V1_in_wideMINT1B = V1 INSIDE wide_MINT1B
NOT RECTANGLE V1_in_wideMINT1B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT1027A{
@ RULE_MINT1027A
@ MINT1A minimum area for rectangular shape is 0.0024um2
rect_MINT1A = RECTANGLE MINT1A
AREA rect_MINT1A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT1027B{
@ RULE_MINT1027B
@ MINT1B minimum area for rectangular shape is 0.0024um2
rect_MINT1B = RECTANGLE MINT1B
AREA rect_MINT1B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT1028A{
@ RULE_MINT1028A
@ MINT1A min area for non-rectangular shape is 0.0036um2
no_rect_MINT1A = NOT RECTANGLE MINT1A
AREA no_rect_MINT1A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT1028B{
@ RULE_MINT1028B
@ MINT1B min area for non-rectangular shape is 0.0036um2
no_rect_MINT1B = NOT RECTANGLE MINT1B
AREA no_rect_MINT1B < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT1029A{
//@ RULE_MINT1029A
//@ MINT1A preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT1A
//vert_edges = MINT1A ANGLE == 90
//hor_edges = MINT1A ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT1A hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT1029B{
//@ RULE_MINT1029B
//@ MINT1B preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT1A
//vert_edges = MINT1B ANGLE == 90
//hor_edges = MINT1B ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT1B hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MINT2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MINT2001A{
@ RULE_MINT2001B
@ MINT2A width > 28nm 
INTERNAL MINT2A < 0.028 
}
//XXX INTERNAL MINT2A < 0.028 
//INTERNAL MINT2A > 0.028 < 0.032
//INTERNAL MINT2A > 0.032 < 0.040
//INTERNAL MINT2A > 0.040 < 2.400
//INTERNAL MINT2A > 2.4 < 10
//} changed to INTERNAL MINT2A < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT2001B{
@ RULE_MINT2001B
@ MINT2A width > 28nm
INTERNAL MINT2B < 0.028 
}
//XXX INTERNAL MINT2B < 0.028 
//INTERNAL MINT2B > 0.028 < 0.032
//INTERNAL MINT2B > 0.032 < 0.040
//INTERNAL MINT2B > 0.040 < 2.400
//INTERNAL MINT2B > 2.4 < 10
//} changed to INTERNAL MINT2B < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT2002A{
@ RULE_MINT2002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT2A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2002B{
@ RULE_MINT2002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT2B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2003A{
@ RULE_MINT2003A
@ maximum length of MINT2A for wires with min width 28nm is 960nm
wide_MINT2A = MINT2A with width <= 0.028
d = INT wide_MINT2A <= 1 opposite
d_p = dfm property wide_MINT2A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2003B{
@ RULE_MINT2003B
@ maximum length of MINT2B for wires with min width 28nm is 960nm
wide_MINT2B = MINT2B with width <= 0.028
d = INT wide_MINT2B <= 1 opposite
d_p = dfm property wide_MINT2B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//XXX changed M1A with width from >=0.028 to <=0.028
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2004A{
@ RULE_MINT2004A
@ MINT2A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT2A_eol = LENGTH MINT2A < 0.032
EXT MINT2A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2004B{
@ RULE_MINT2004B
@ MINT2B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT2B_eol = LENGTH MINT2B < 0.032
EXT MINT2B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2005A{
@ RULE_MINT2005A
@ MINT2A min space and notch 54nm
EXT MINT2A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2005B{
@ RULE_MINT2005B
@ MINT2B min space and notch 54nm
EXT MINT2B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT2006{
@ RULE_MINT2006
@ min spacing of MINT2A to MINT2B 36nm
EXT MINT2A MINT2B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2007{
@ RULE_MINT2007
@ End-of-line spacing of MINT2A to MINT2B (EOL edge defined as edge < 32nm) is 44nm
MINT2A_eol = LENGTH MINT2A < 0.032
MINT2B_eol = LENGTH MINT2B < 0.032
EXT MINT2A_eol MINT2B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2008A{
@ RULE_MINT2008A
@ Minimum spacing of MINT2A when MINT2A is wider than 32nm and longer than 240nm is 68nm
MINT2A_wide = MINT2A WITH WIDTH > 0.032
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2008B{
@ RULE_MINT2008B
@ Minimum spacing of MINT2B when MINT2B is wider than 32nm and longer than 240nm is 68nm
MINT2B_wide = MINT2B WITH WIDTH > 0.032
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2009A{
@ RULE_MINT2009A
@ Minimum spacing of MINT2A when MINT2A is wider than 40nm and longer than 240nm is 76nm
MINT2A_wide = MINT2A WITH WIDTH > 0.040
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2009B{
@ RULE_MINT2009B
@ Minimum spacing of MINT2B when MINT2B is wider than 40nm and longer than 240nm is 76nm
MINT2B_wide = MINT2B WITH WIDTH > 0.040
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2010A{
@ RULE_MINT2010A
@ Minimum spacing of MINT2A when MINT2A is wider than 64nm and longer than 480nm is 92nm
MINT2A_wide = MINT2A WITH WIDTH > 0.064
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT2A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2010B{
@ RULE_MINT2010B
@ Minimum spacing of MINT2B when MINT2B is wider than 64nm and longer than 480nm is 92nm
MINT2B_wide = MINT2B WITH WIDTH > 0.064
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT2B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2011A{
@ RULE_MINT2011A
@ Minimum spacing of MINT2A when MINT2A is wider than 120nm and longer than 1200nm is 120nm
MINT2A_wide = MINT2A WITH WIDTH > 0.120
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT2A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2011B{
@ RULE_MINT2011B
@ Minimum spacing of MINT2B when MINT2B is wider than 120nm and longer than 1200nm is 120nm
MINT2B_wide = MINT2B WITH WIDTH > 0.120
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT2B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2012A{
@ RULE_MINT2012A
@ Minimum spacing of MINT2A when MINT2A is wider than 240nm and longer than 1800nm is 240nm
MINT2A_wide = MINT2A WITH WIDTH > 0.240
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT2A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2012B{
@ RULE_MINT2012B
@ Minimum spacing of MINT2B when MINT2B is wider than 240nm and longer than 1800nm is 240nm
MINT2B_wide = MINT2B WITH WIDTH > 0.240
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT2B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2013A{
@ RULE_MINT2013A
@ Minimum spacing of MINT2A when MINT2A is wider than 320nm and longer than 2400nm is 320nm
MINT2A_wide = MINT2A WITH WIDTH > 0.320
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2013B{
@ RULE_MINT2013B
@ Minimum spacing of MINT2B when MINT2B is wider than 320nm and longer than 2400nm is 320nm
MINT2B_wide = MINT2B WITH WIDTH > 0.320
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2014A{
@ RULE_MINT2014A
@ Minimum spacing of MINT2A when MINT2A is wider than 600nm and longer than 2400nm is 600nm
MINT2A_wide = MINT2A WITH WIDTH > 0.600
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2014B{
@ RULE_MINT2014B
@ Minimum spacing of MINT2B when MINT2B is wider than 600nm and longer than 2400nm is 600nm
MINT2B_wide = MINT2B WITH WIDTH > 0.600
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2015A{
@ RULE_MINT2015A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 32nm and longer than 240nm is 44nm
MINT2B_wide = MINT2B WITH WIDTH > 0.032
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2015B{
@ RULE_MINT2015B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 32nm and longer than 240nm is 44nm
MINT2A_wide = MINT2A WITH WIDTH > 0.032
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2016A{
@ RULE_MINT2016A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 40nm and longer than 240nm is 50nm
MINT2B_wide = MINT2B WITH WIDTH > 0.040
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2016B{
@ RULE_MINT2016B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 40nm and longer than 240nm is 50nm
MINT2A_wide = MINT2A WITH WIDTH > 0.040
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT2B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2017A{
@ RULE_MINT2017A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 64nm and longer than 480nm is 60nm
MINT2B_wide = MINT2B WITH WIDTH > 0.064
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT2A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2017B{
@ RULE_MINT2017B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 64nm and longer than 480nm is 60nm
MINT2A_wide = MINT2A WITH WIDTH > 0.064
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT2B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2018A{
@ RULE_MINT2018A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 120nm and longer than 1200nm is 78nm
MINT2B_wide = MINT2B WITH WIDTH > 0.120
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT2A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2018B{
@ RULE_MINT2018B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 120nm and longer than 1200nm is 78nm
MINT2A_wide = MINT2A WITH WIDTH > 0.120
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT2B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2019A{
@ RULE_MINT2019A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 240nm and longer than 1800nm is 156nm
MINT2B_wide = MINT2B WITH WIDTH > 0.240
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT2A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2019B{
@ RULE_MINT2019B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 240nm and longer than 1800nm is 156nm
MINT2A_wide = MINT2A WITH WIDTH > 0.240
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT2B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2020A{
@ RULE_MINT2020A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 320nm and longer than 2400nm is 200nm
MINT2B_wide = MINT2B WITH WIDTH > 0.320
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2020B{
@ RULE_MINT2020B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 320nm and longer than 2400nm is 200nm
MINT2A_wide = MINT2A WITH WIDTH > 0.320
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2021A{
@ RULE_MINT2021A
@ Minimum spacing of MINT2A to MINT2B when MINT2B is wider than 600nm and longer than 2400nm is 400nm
MINT2B_wide = MINT2B WITH WIDTH > 0.600
d = INT MINT2B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2021B{
@ RULE_MINT2021B
@ Minimum spacing of MINT2B to MINT2A when MINT2A is wider than 600nm and longer than 2400nm is 400nm
MINT2A_wide = MINT2A WITH WIDTH > 0.600
d = INT MINT2A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT2A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT2B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2022{
@ RULE_MINT2022
@ Minimum overlap of MINT2A and MINT2B (stitch region length)
MINT2AB_stitch = MINT2A AND MINT2B
INT MINT2AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2023A{
@ RULE_MINT2023A
@ Allowed enclosures of V2 by MINT2A
RECTANGLE ENCLOSURE V2 MINT2A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
// XXX RECTANGLE ENCLOSURE V2 MINT2A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V2 MINT2A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2023B{
@ RULE_MINT2023B
@ Allowed enclosures of V2 by MINT2B
RECTANGLE ENCLOSURE V2 MINT2B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
// XXX V0 changed to V2
/// XXX RECTANGLE ENCLOSURE V0 MINT2B ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V2 MINT2B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2024{
@ RULE_MINT2024
@ Allowed enclosures of V2 by MINT2A-MINT2B stitches
MINT2AB_stitch = MINT2A AND MINT2B
RECTANGLE ENCLOSURE V2 MINT2AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
// XXX V0 changed to V2
/// XXX RECTANGLE ENCLOSURE V0 MINT2AB_stitch ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V2 MINT2AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
//RULE_MINT2025A{
//@ RULE_MINT2025A
//@ V2 center must be aligned to wire center (between 2 longest edges)
//V2_MINT2A_OVERLAP =  V2 AND MINT2A
//// deriving metal and via edge pairs
//MINT2A_edges = INT MINT2A < 1
//V2_edges = INT V2 < 1
//// deriving metal and via center lines
//MINT2A_centerline = DFM COPY MINT2A_edges CENTERLINE
//V2_centerline = DFM COPY V2_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT2A_centerline COIN EDGE V2_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V2_MINT2A_OVERLAP NOT INTERACT y
//}
//// XXX V2 NOT INTERACT y 
//// changed to V2_MINT2A_OVERLAP NOT INTERACT y 
//// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
///////////////////////////////////////////////////////////////////////////////////
//RULE_MINT2025B{
//@ RULE_MINT2025B
//@ V2 center must be aligned to wire center (between 2 longest edges)
//V2_MINT2B_OVERLAP = V2 AND MINT2B
//// deriving metal and via edge pairs
//MINT2B_edges = INT MINT2B < 1
//V2_edges = INT V2 < 1
//// deriving metal and via center lines
//MINT2B_centerline = DFM COPY MINT2B_edges CENTERLINE
//V2_centerline = DFM COPY V2_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT2B_centerline COIN EDGE V2_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V2_MINT2B_OVERLAP NOT INTERACT y
//}
// XXX V2 NOT INTERACT y 
// changed to V2_MINT2B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2026A{
@ RULE_MINT2026A
@ V2 shape must be rectangular if enclosing MINT2A wire width >= 60nm
wide_MINT2A = MINT2A WITH WIDTH >= 0.060
V2_in_wideMINT2A = V2 INSIDE wide_MINT2A
NOT RECTANGLE V2_in_wideMINT2A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2026B{
@ RULE_MINT2026B
@ V2 shape must be rectangular if enclosing MINT2B wire width >= 60nm
wide_MINT2B = MINT2B WITH WIDTH >= 0.060
V2_in_wideMINT2B = V2 INSIDE wide_MINT2B
NOT RECTANGLE V2_in_wideMINT2B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT2027A{
@ RULE_MINT2027A
@ MINT2A minimum area for rectangular shape is 0.0024um2
rect_MINT2A = RECTANGLE MINT2A
AREA rect_MINT2A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT2027B{
@ RULE_MINT2027B
@ MINT2B minimum area for rectangular shape is 0.0024um2
rect_MINT2B = RECTANGLE MINT2B
AREA rect_MINT2B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT2028A{
@ RULE_MINT2028A
@ MINT2A min area for non-rectangular shape is 0.0036um2
no_rect_MINT2A = NOT RECTANGLE MINT2A
AREA no_rect_MINT2A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT2028B{
@ RULE_MINT2028B
@ MINT2B min area for non-rectangular shape is 0.0036um2
no_rect_MINT2B = NOT RECTANGLE MINT2B
AREA no_rect_MINT2B < 0.0036
}
//XXX MINTn.29 removed
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT2029A{
//@ RULE_MINT2029A
//@ MINT2A preferred routing direction is horizontal (all polygons should be horizontal)
//derive horizontal and vertical edges of MINT2A
//vert_edges = MINT2A ANGLE == 90
//hor_edges = MINT2A ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//vert_polygons = DFM PROPERTY MINT2A hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
//output vertical polygons
//COPY vert_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT2029B{
//@ RULE_MINT2029B
//@ MINT2B preferred routing direction is horizontal (all polygons should be horizontal)
//derive horizontal and vertical edges of MINT2B
//vert_edges = MINT2B ANGLE == 90
//hor_edges = MINT2B ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//vert_polygons = DFM PROPERTY MINT2B hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
//output vertical polygons
//COPY vert_polygons
//}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MINT3 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MINT3001A{
@ RULE_MINT3001B
@ MINT3A width > 28nm
INTERNAL MINT3A < 0.028 
}
//XXX INTERNAL MINT3A < 0.028 
//INTERNAL MINT3A > 0.028 < 0.032
//INTERNAL MINT3A > 0.032 < 0.040
//INTERNAL MINT3A > 0.040 < 2.400
//INTERNAL MINT3A > 2.4 < 10
//} changed to INTERNAL MINT3A < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT3001B{
@ RULE_MINT3001B
@ MINT3A width > 28nm
INTERNAL MINT3B < 0.028 
}
//XXX INTERNAL MINT3B < 0.028 
//INTERNAL MINT3B > 0.028 < 0.032
//INTERNAL MINT3B > 0.032 < 0.040
//INTERNAL MINT3B > 0.040 < 2.400
//INTERNAL MINT3B > 2.4 < 10
//} changed to INTERNAL MINT3B < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT3002A{
@ RULE_MINT3002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT3A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3002B{
@ RULE_MINT3002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT3B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3003A{
@ RULE_MINT3003A
@ maximum length of MINT3A for wires with min width 28nm is 960nm
wide_MINT3A = MINT3A with width >= 0.028
d = INT wide_MINT3A <= 1 opposite
d_p = dfm property wide_MINT3A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3003B{
@ RULE_MINT3003B
@ maximum length of MINT3B for wires with min width 28nm is 960nm
wide_MINT3B = MINT3B with width >= 0.028
d = INT wide_MINT3B <= 1 opposite
d_p = dfm property wide_MINT3B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3004A{
@ RULE_MINT3004A
@ MINT3A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT3A_eol = LENGTH MINT3A < 0.032
EXT MINT3A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3004B{
@ RULE_MINT3004B
@ MINT3B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT3B_eol = LENGTH MINT3B < 0.032
EXT MINT3B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3005A{
@ RULE_MINT3005A
@ MINT3A min space and notch 54nm
EXT MINT3A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3005B{
@ RULE_MINT3005B
@ MINT3B min space and notch 54nm
EXT MINT3B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT3006{
@ RULE_MINT3006
@ min spacing of MINT3A to MINT3B 36nm
EXT MINT3A MINT3B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3007{
@ RULE_MINT3007
@ End-of-line spacing of MINT3A to MINT3B (EOL edge defined as edge < 32nm) is 44nm
MINT3A_eol = LENGTH MINT3A < 0.032
MINT3B_eol = LENGTH MINT3B < 0.032
EXT MINT3A_eol MINT3B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3008A{
@ RULE_MINT3008A
@ Minimum spacing of MINT3A when MINT3A is wider than 32nm and longer than 240nm is 68nm
MINT3A_wide = MINT3A WITH WIDTH > 0.032
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3008B{
@ RULE_MINT3008B
@ Minimum spacing of MINT3B when MINT3B is wider than 32nm and longer than 240nm is 68nm
MINT3B_wide = MINT3B WITH WIDTH > 0.032
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3009A{
@ RULE_MINT3009A
@ Minimum spacing of MINT3A when MINT3A is wider than 40nm and longer than 240nm is 76nm
MINT3A_wide = MINT3A WITH WIDTH > 0.040
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3009B{
@ RULE_MINT3009B
@ Minimum spacing of MINT3B when MINT3B is wider than 40nm and longer than 240nm is 76nm
MINT3B_wide = MINT3B WITH WIDTH > 0.040
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3010A{
@ RULE_MINT3010A
@ Minimum spacing of MINT3A when MINT3A is wider than 64nm and longer than 480nm is 92nm
MINT3A_wide = MINT3A WITH WIDTH > 0.064
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT3A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3010B{
@ RULE_MINT3010B
@ Minimum spacing of MINT3B when MINT3B is wider than 64nm and longer than 480nm is 92nm
MINT3B_wide = MINT3B WITH WIDTH > 0.064
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT3B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3011A{
@ RULE_MINT3011A
@ Minimum spacing of MINT3A when MINT3A is wider than 120nm and longer than 1200nm is 120nm
MINT3A_wide = MINT3A WITH WIDTH > 0.120
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT3A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3011B{
@ RULE_MINT3011B
@ Minimum spacing of MINT3B when MINT3B is wider than 120nm and longer than 1200nm is 120nm
MINT3B_wide = MINT3B WITH WIDTH > 0.120
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT3B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3012A{
@ RULE_MINT3012A
@ Minimum spacing of MINT3A when MINT3A is wider than 240nm and longer than 1800nm is 240nm
MINT3A_wide = MINT3A WITH WIDTH > 0.240
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT3A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3012B{
@ RULE_MINT3012B
@ Minimum spacing of MINT3B when MINT3B is wider than 240nm and longer than 1800nm is 240nm
MINT3B_wide = MINT3B WITH WIDTH > 0.240
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT3B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3013A{
@ RULE_MINT3013A
@ Minimum spacing of MINT3A when MINT3A is wider than 320nm and longer than 2400nm is 320nm
MINT3A_wide = MINT3A WITH WIDTH > 0.320
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3013B{
@ RULE_MINT3013B
@ Minimum spacing of MINT3B when MINT3B is wider than 320nm and longer than 2400nm is 320nm
MINT3B_wide = MINT3B WITH WIDTH > 0.320
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3014A{
@ RULE_MINT3014A
@ Minimum spacing of MINT3A when MINT3A is wider than 600nm and longer than 2400nm is 600nm
MINT3A_wide = MINT3A WITH WIDTH > 0.600
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3014B{
@ RULE_MINT3014B
@ Minimum spacing of MINT3B when MINT3B is wider than 600nm and longer than 2400nm is 600nm
MINT3B_wide = MINT3B WITH WIDTH > 0.600
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3015A{
@ RULE_MINT3015A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 32nm and longer than 240nm is 44nm
MINT3B_wide = MINT3B WITH WIDTH > 0.032
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3015B{
@ RULE_MINT3015B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 32nm and longer than 240nm is 44nm
MINT3A_wide = MINT3A WITH WIDTH > 0.032
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3016A{
@ RULE_MINT3016A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 40nm and longer than 240nm is 50nm
MINT3B_wide = MINT3B WITH WIDTH > 0.040
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3016B{
@ RULE_MINT3016B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 40nm and longer than 240nm is 50nm
MINT3A_wide = MINT3A WITH WIDTH > 0.040
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT3B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3017A{
@ RULE_MINT3017A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 64nm and longer than 480nm is 60nm
MINT3B_wide = MINT3B WITH WIDTH > 0.064
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT3A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3017B{
@ RULE_MINT3017B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 64nm and longer than 480nm is 60nm
MINT3A_wide = MINT3A WITH WIDTH > 0.064
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT3B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3018A{
@ RULE_MINT3018A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 120nm and longer than 1200nm is 78nm
MINT3B_wide = MINT3B WITH WIDTH > 0.120
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT3A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3018B{
@ RULE_MINT3018B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 120nm and longer than 1200nm is 78nm
MINT3A_wide = MINT3A WITH WIDTH > 0.120
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT3B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3019A{
@ RULE_MINT3019A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 240nm and longer than 1800nm is 156nm
MINT3B_wide = MINT3B WITH WIDTH > 0.240
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT3A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3019B{
@ RULE_MINT3019B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 240nm and longer than 1800nm is 156nm
MINT3A_wide = MINT3A WITH WIDTH > 0.240
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT3B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3020A{
@ RULE_MINT3020A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 320nm and longer than 2400nm is 200nm
MINT3B_wide = MINT3B WITH WIDTH > 0.320
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3020B{
@ RULE_MINT3020B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 320nm and longer than 2400nm is 200nm
MINT3A_wide = MINT3A WITH WIDTH > 0.320
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3021A{
@ RULE_MINT3021A
@ Minimum spacing of MINT3A to MINT3B when MINT3B is wider than 600nm and longer than 2400nm is 400nm
MINT3B_wide = MINT3B WITH WIDTH > 0.600
d = INT MINT3B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3021B{
@ RULE_MINT3021B
@ Minimum spacing of MINT3B to MINT3A when MINT3A is wider than 600nm and longer than 2400nm is 400nm
MINT3A_wide = MINT3A WITH WIDTH > 0.600
d = INT MINT3A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT3A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT3B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3022{
@ RULE_MINT3022
@ Minimum overlap of MINT3A and MINT3B (stitch region length)
MINT3AB_stitch = MINT3A AND MINT3B
INT MINT3AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3023A{
@ RULE_MINT3023A
@ Allowed enclosures of V3 by MINT3A
RECTANGLE ENCLOSURE V3 MINT3A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
// XXX RECTANGLE ENCLOSURE V3 MINT3A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V3 MINT3A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
// XXX V0 changed to V3
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3023B{
@ RULE_MINT3023B
@ Allowed enclosures of V3 by MINT3B
RECTANGLE ENCLOSURE V3 MINT3B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX V0 changed to V3
// XXX RECTANGLE ENCLOSURE V3 MINT3B ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V3 MINT3B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3024{
@ RULE_MINT3024
@ Allowed enclosures of V3 by MINT3A-MINT3B stitches
MINT3AB_stitch = MINT3A AND MINT3B
RECTANGLE ENCLOSURE V3 MINT3AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
// XXX RECTANGLE ENCLOSURE V3 MINT3AB_stitch ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V3 MINT3AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
// XXX V0 changed to V3
/////////////////////////////////////////////////////////////////////////////////
//RULE_MINT3025A{
//@ RULE_MINT3025A
//@ V3 center must be aligned to wire center (between 2 longest edges)
//V3_MINT3A_OVERLAP = V3 AND MINT3A
//// deriving metal and via edge pairs
//MINT3A_edges = INT MINT3A < 1
//V3_edges = INT V3 < 1
//// deriving metal and via center lines
//MINT3A_centerline = DFM COPY MINT3A_edges CENTERLINE
//V3_centerline = DFM COPY V3_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT3A_centerline COIN EDGE V3_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V3_MINT3A_OVERLAP NOT INTERACT y
//}
//// XXX V3 NOT INTERACT y 
//// changed to V3_MINT3A_OVERLAP NOT INTERACT y 
//// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
///////////////////////////////////////////////////////////////////////////////////
//RULE_MINT3025B{
//@ RULE_MINT3025B
//@ V3 center must be aligned to wire center (between 2 longest edges)
//V3_MINT3B_OVERLAP =  V3 AND MINT3B
//// deriving metal and via edge pairs
//MINT3B_edges = INT MINT3B < 1
//V3_edges = INT V3 < 1
//// deriving metal and via center lines
//MINT3B_centerline = DFM COPY MINT3B_edges CENTERLINE
//V3_centerline = DFM COPY V3_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT3B_centerline COIN EDGE V3_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V3_MINT3B_OVERLAP NOT INTERACT y
//}
// XXX V3 NOT INTERACT y 
// changed to V3_MINT3B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3026A{
@ RULE_MINT3026A
@ V3 shape must be rectangular if enclosing MINT3A wire width >= 60nm
wide_MINT3A = MINT3A WITH WIDTH >= 0.060
V3_in_wideMINT3A = V3 INSIDE wide_MINT3A
NOT RECTANGLE V3_in_wideMINT3A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3026B{
@ RULE_MINT3026B
@ V3 shape must be rectangular if enclosing MINT3B wire width >= 60nm
wide_MINT3B = MINT3B WITH WIDTH >= 0.060
V3_in_wideMINT3B = V3 INSIDE wide_MINT3B
NOT RECTANGLE V3_in_wideMINT3B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT3027A{
@ RULE_MINT3027A
@ MINT3A minimum area for rectangular shape is 0.0024um2
rect_MINT3A = RECTANGLE MINT3A
AREA rect_MINT3A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT3027B{
@ RULE_MINT3027B
@ MINT3B minimum area for rectangular shape is 0.0024um2
rect_MINT3B = RECTANGLE MINT3B
AREA rect_MINT3B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT3028A{
@ RULE_MINT3028A
@ MINT3A min area for non-rectangular shape is 0.0036um2
no_rect_MINT3A = NOT RECTANGLE MINT3A
AREA no_rect_MINT3A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT3028B{
@ RULE_MINT3028B
@ MINT3B min area for non-rectangular shape is 0.0036um2
no_rect_MINT3B = NOT RECTANGLE MINT3B
AREA no_rect_MINT3B < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT3029A{
//@ RULE_MINT3029A
//@ MINT3A preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT3A
//vert_edges = MINT3A ANGLE == 90
//hor_edges = MINT3A ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT3A hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT3029B{
//@ RULE_MINT3029B
//@ MINT3B preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT3A
//vert_edges = MINT3B ANGLE == 90
//hor_edges = MINT3B ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT3B hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MINT4 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MINT4001A{
@ RULE_MINT4001B
@ MINT4A width > 28nm
INTERNAL MINT4A < 0.028 
}
//XXX INTERNAL MINT4A < 0.028 
//INTERNAL MINT4A > 0.028 < 0.032
//INTERNAL MINT4A > 0.032 < 0.040
//INTERNAL MINT4A > 0.040 < 2.400
//INTERNAL MINT4A > 2.4 < 10
//} changed to INTERNAL MINT4A < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT4001B{
@ RULE_MINT4001B
@ MINT4A width > 28nm
INTERNAL MINT4B < 0.028 
}
//XXX INTERNAL MINT4B < 0.028 
//INTERNAL MINT4B > 0.028 < 0.032
//INTERNAL MINT4B > 0.032 < 0.040
//INTERNAL MINT4B > 0.040 < 2.400
//INTERNAL MINT4B > 2.4 < 10
//} changed to INTERNAL MINT4B < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT4002A{
@ RULE_MINT4002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT4A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4002B{
@ RULE_MINT4002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT4B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4003A{
@ RULE_MINT4003A
@ maximum length of MINT4A for wires with min width 28nm is 960nm
wide_MINT4A = MINT4A with width >= 0.028
d = INT wide_MINT4A <= 1 opposite
d_p = dfm property wide_MINT4A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4003B{
@ RULE_MINT4003B
@ maximum length of MINT4B for wires with min width 28nm is 960nm
wide_MINT4B = MINT4B with width >= 0.028
d = INT wide_MINT4B <= 1 opposite
d_p = dfm property wide_MINT4B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4004A{
@ RULE_MINT4004A
@ MINT4A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT4A_eol = LENGTH MINT4A < 0.032
EXT MINT4A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4004B{
@ RULE_MINT4004B
@ MINT4B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT4B_eol = LENGTH MINT4B < 0.032
EXT MINT4B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4005A{
@ RULE_MINT4005A
@ MINT4A min space and notch 54nm
EXT MINT4A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4005B{
@ RULE_MINT4005B
@ MINT4B min space and notch 54nm
EXT MINT4B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT4006{
@ RULE_MINT4006
@ min spacing of MINT4A to MINT4B 36nm
EXT MINT4A MINT4B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4007{
@ RULE_MINT4007
@ End-of-line spacing of MINT4A to MINT4B (EOL edge defined as edge < 32nm) is 44nm
MINT4A_eol = LENGTH MINT4A < 0.032
MINT4B_eol = LENGTH MINT4B < 0.032
EXT MINT4A_eol MINT4B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4008A{
@ RULE_MINT4008A
@ Minimum spacing of MINT4A when MINT4A is wider than 32nm and longer than 240nm is 68nm
MINT4A_wide = MINT4A WITH WIDTH > 0.032
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4008B{
@ RULE_MINT4008B
@ Minimum spacing of MINT4B when MINT4B is wider than 32nm and longer than 240nm is 68nm
MINT4B_wide = MINT4B WITH WIDTH > 0.032
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4009A{
@ RULE_MINT4009A
@ Minimum spacing of MINT4A when MINT4A is wider than 40nm and longer than 240nm is 76nm
MINT4A_wide = MINT4A WITH WIDTH > 0.040
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4009B{
@ RULE_MINT4009B
@ Minimum spacing of MINT4B when MINT4B is wider than 40nm and longer than 240nm is 76nm
MINT4B_wide = MINT4B WITH WIDTH > 0.040
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4010A{
@ RULE_MINT4010A
@ Minimum spacing of MINT4A when MINT4A is wider than 64nm and longer than 480nm is 92nm
MINT4A_wide = MINT4A WITH WIDTH > 0.064
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT4A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4010B{
@ RULE_MINT4010B
@ Minimum spacing of MINT4B when MINT4B is wider than 64nm and longer than 480nm is 92nm
MINT4B_wide = MINT4B WITH WIDTH > 0.064
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT4B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4011A{
@ RULE_MINT4011A
@ Minimum spacing of MINT4A when MINT4A is wider than 120nm and longer than 1200nm is 120nm
MINT4A_wide = MINT4A WITH WIDTH > 0.120
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT4A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4011B{
@ RULE_MINT4011B
@ Minimum spacing of MINT4B when MINT4B is wider than 120nm and longer than 1200nm is 120nm
MINT4B_wide = MINT4B WITH WIDTH > 0.120
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT4B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4012A{
@ RULE_MINT4012A
@ Minimum spacing of MINT4A when MINT4A is wider than 240nm and longer than 1800nm is 240nm
MINT4A_wide = MINT4A WITH WIDTH > 0.240
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT4A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4012B{
@ RULE_MINT4012B
@ Minimum spacing of MINT4B when MINT4B is wider than 240nm and longer than 1800nm is 240nm
MINT4B_wide = MINT4B WITH WIDTH > 0.240
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT4B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4013A{
@ RULE_MINT4013A
@ Minimum spacing of MINT4A when MINT4A is wider than 320nm and longer than 2400nm is 320nm
MINT4A_wide = MINT4A WITH WIDTH > 0.320
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4013B{
@ RULE_MINT4013B
@ Minimum spacing of MINT4B when MINT4B is wider than 320nm and longer than 2400nm is 320nm
MINT4B_wide = MINT4B WITH WIDTH > 0.320
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4014A{
@ RULE_MINT4014A
@ Minimum spacing of MINT4A when MINT4A is wider than 600nm and longer than 2400nm is 600nm
MINT4A_wide = MINT4A WITH WIDTH > 0.600
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4014B{
@ RULE_MINT4014B
@ Minimum spacing of MINT4B when MINT4B is wider than 600nm and longer than 2400nm is 600nm
MINT4B_wide = MINT4B WITH WIDTH > 0.600
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4015A{
@ RULE_MINT4015A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 32nm and longer than 240nm is 44nm
MINT4B_wide = MINT4B WITH WIDTH > 0.032
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4015B{
@ RULE_MINT4015B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 32nm and longer than 240nm is 44nm
MINT4A_wide = MINT4A WITH WIDTH > 0.032
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4016A{
@ RULE_MINT4016A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 40nm and longer than 240nm is 50nm
MINT4B_wide = MINT4B WITH WIDTH > 0.040
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4016B{
@ RULE_MINT4016B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 40nm and longer than 240nm is 50nm
MINT4A_wide = MINT4A WITH WIDTH > 0.040
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT4B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4017A{
@ RULE_MINT4017A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 64nm and longer than 480nm is 60nm
MINT4B_wide = MINT4B WITH WIDTH > 0.064
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT4A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4017B{
@ RULE_MINT4017B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 64nm and longer than 480nm is 60nm
MINT4A_wide = MINT4A WITH WIDTH > 0.064
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT4B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4018A{
@ RULE_MINT4018A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 120nm and longer than 1200nm is 78nm
MINT4B_wide = MINT4B WITH WIDTH > 0.120
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT4A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4018B{
@ RULE_MINT4018B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 120nm and longer than 1200nm is 78nm
MINT4A_wide = MINT4A WITH WIDTH > 0.120
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT4B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4019A{
@ RULE_MINT4019A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 240nm and longer than 1800nm is 156nm
MINT4B_wide = MINT4B WITH WIDTH > 0.240
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT4A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4019B{
@ RULE_MINT4019B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 240nm and longer than 1800nm is 156nm
MINT4A_wide = MINT4A WITH WIDTH > 0.240
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT4B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4020A{
@ RULE_MINT4020A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 320nm and longer than 2400nm is 200nm
MINT4B_wide = MINT4B WITH WIDTH > 0.320
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4020B{
@ RULE_MINT4020B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 320nm and longer than 2400nm is 200nm
MINT4A_wide = MINT4A WITH WIDTH > 0.320
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4021A{
@ RULE_MINT4021A
@ Minimum spacing of MINT4A to MINT4B when MINT4B is wider than 600nm and longer than 2400nm is 400nm
MINT4B_wide = MINT4B WITH WIDTH > 0.600
d = INT MINT4B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4021B{
@ RULE_MINT4021B
@ Minimum spacing of MINT4B to MINT4A when MINT4A is wider than 600nm and longer than 2400nm is 400nm
MINT4A_wide = MINT4A WITH WIDTH > 0.600
d = INT MINT4A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT4A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT4B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4022{
@ RULE_MINT4022
@ Minimum overlap of MINT4A and MINT4B (stitch region length)
MINT4AB_stitch = MINT4A AND MINT4B
INT MINT4AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4023A{
@ RULE_MINT4023A
@ Allowed enclosures of V4 by MINT4A
RECTANGLE ENCLOSURE V4 MINT4A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX V0 changed to V4
// XXX RECTANGLE ENCLOSURE V4 MINT4A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V4 MINT4A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4023B{
@ RULE_MINT4023B
@ Allowed enclosures of V4 by MINT4B
RECTANGLE ENCLOSURE V4 MINT4B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX V0 changed to V4
// XXX RECTANGLE ENCLOSURE V4 MINT4A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V4 MINT4A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4024{
@ RULE_MINT4024
@ Allowed enclosures of V4 by MINT4A-MINT4B stitches
MINT4AB_stitch = MINT4A AND MINT4B
RECTANGLE ENCLOSURE V4 MINT4AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
/// XXX V0 changed to V4
// XXX RECTANGLE ENCLOSURE V4 MINT4AB_stitch ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V4 MINT4AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
//RULE_MINT4025A{
//@ RULE_MINT4025A
//@ V4 center must be aligned to wire center (between 2 longest edges)
//V4_MINT4A_OVERLAP = MINT4A AND V4
//// deriving metal and via edge pairs
//MINT4A_edges = INT MINT4A < 1
//V4_edges = INT V4 < 1
//// deriving metal and via center lines
//MINT4A_centerline = DFM COPY MINT4A_edges CENTERLINE
//V4_centerline = DFM COPY V4_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT4A_centerline COIN EDGE V4_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V4_MINT4A_OVERLAP NOT INTERACT y
//}
//// XXX V4 NOT INTERACT y 
//// changed to V4_MINT4A_OVERLAP NOT INTERACT y 
//// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
///////////////////////////////////////////////////////////////////////////////////
//RULE_MINT4025B{
//@ RULE_MINT4025B
//@ V4 center must be aligned to wire center (between 2 longest edges)
//V4_MINT4B_OVERLAP = V4 AND MINT4B
//// deriving metal and via edge pairs
//MINT4B_edges = INT MINT4B < 1
//V4_edges = INT V4 < 1
//// deriving metal and via center lines
//MINT4B_centerline = DFM COPY MINT4B_edges CENTERLINE
//V4_centerline = DFM COPY V4_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT4B_centerline COIN EDGE V4_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V4_MINT4B_OVERLAP NOT INTERACT y
//}
// XXX V4 NOT INTERACT y 
// changed to V4_MINT4B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4026A{
@ RULE_MINT4026A
@ V4 shape must be rectangular if enclosing MINT4A wire width >= 60nm
wide_MINT4A = MINT4A WITH WIDTH >= 0.060
V4_in_wideMINT4A = V4 INSIDE wide_MINT4A
NOT RECTANGLE V4_in_wideMINT4A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4026B{
@ RULE_MINT4026B
@ V4 shape must be rectangular if enclosing MINT4B wire width >= 60nm
wide_MINT4B = MINT4B WITH WIDTH >= 0.060
V4_in_wideMINT4B = V4 INSIDE wide_MINT4B
NOT RECTANGLE V4_in_wideMINT4B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT4027A{
@ RULE_MINT4027A
@ MINT4A minimum area for rectangular shape is 0.0024um2
rect_MINT4A = RECTANGLE MINT4A
AREA rect_MINT4A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT4027B{
@ RULE_MINT4027B
@ MINT4B minimum area for rectangular shape is 0.0024um2
rect_MINT4B = RECTANGLE MINT4B
AREA rect_MINT4B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT4028A{
@ RULE_MINT4028A
@ MINT4A min area for non-rectangular shape is 0.0036um2
no_rect_MINT4A = NOT RECTANGLE MINT4A
AREA no_rect_MINT4A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT4028B{
@ RULE_MINT4028B
@ MINT4B min area for non-rectangular shape is 0.0036um2
no_rect_MINT4B = NOT RECTANGLE MINT4B
AREA no_rect_MINT4B < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT4029A{
//@ RULE_MINT4029A
//@ MINT4A preferred routing direction is horizontal (all polygons should be horizontal)
//derive horizontal and vertical edges of MINT4A
//vert_edges = MINT4A ANGLE == 90
//hor_edges = MINT4A ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//vert_polygons = DFM PROPERTY MINT4A hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
//output vertical polygons
//COPY vert_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT4029B{
//@ RULE_MINT4029B
//@ MINT4B preferred routing direction is horizontal (all polygons should be horizontal)
//derive horizontal and vertical edges of MINT2B
//vert_edges = MINT4B ANGLE == 90
//hor_edges = MINT4B ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//vert_polygons = DFM PROPERTY MINT4B hor_edges_int vert_edges_int OVERLAP MULTI [check1 = EW(vert_edges_int) - EW(hor_edges_int)] < 0
//output vertical polygons
//COPY vert_polygons
//}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MINT5 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MINT5001A{
@ RULE_MINT5001B
@ MINT5A width > 28nm
INTERNAL MINT5A < 0.028 
}
//XXX INTERNAL MINT5A < 0.028 
//INTERNAL MINT5A > 0.028 < 0.032
//INTERNAL MINT5A > 0.032 < 0.040
//INTERNAL MINT5A > 0.040 < 2.400
//INTERNAL MINT5A > 2.4 < 10
//} changed to INTERNAL MINT5A < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT5001B{
@ RULE_MINT5001B
@ MINT5A width > 28nm
INTERNAL MINT5B < 0.028 
}
//XXX INTERNAL MINT5B < 0.028 
//INTERNAL MINT5B > 0.028 < 0.032
//INTERNAL MINT5B > 0.032 < 0.040
//INTERNAL MINT5B > 0.040 < 2.400
//INTERNAL MINT5B > 2.4 < 10
//} changed to INTERNAL MINT5B < 0.028 
///////////////////////////////////////////////////////////////////////////////////
RULE_MINT5002A{
@ RULE_MINT5002A
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT5A ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5002B{
@ RULE_MINT5002B
@ One of two edges connected to the same vertex must have at least one of 56nm
x = CONVEX EDGE MINT5B ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.056
INT x < 0.001 ABUT 
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5003A{
@ RULE_MINT5003A
@ maximum length of MINT5A for wires with min width 28nm is 960nm
wide_MINT5A = MINT5A with width >= 0.028
d = INT wide_MINT5A <= 1 opposite
d_p = dfm property wide_MINT5A d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5003B{
@ RULE_MINT5003B
@ maximum length of MINT5B for wires with min width 28nm is 960nm
wide_MINT5B = MINT5B with width >= 0.028
d = INT wide_MINT5B <= 1 opposite
d_p = dfm property wide_MINT5B d overlap abut also [EC1 = EC(d)] > 0.960
copy d_p
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5004A{
@ RULE_MINT5004A
@ MINT5A end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT5A_eol = LENGTH MINT5A < 0.032
EXT MINT5A_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5004B{
@ RULE_MINT5004B
@ MINT5B end-of-line spacing (end-of-line edge defined as edge < 32nm) is 68nm
MINT5B_eol = LENGTH MINT5B < 0.032
EXT MINT5B_eol < 0.068
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5005A{
@ RULE_MINT5005A
@ MINT5A min space and notch 54nm
EXT MINT5A < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5005B{
@ RULE_MINT5005B
@ MINT5B min space and notch 54nm
EXT MINT5B < 0.054 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MINT5006{
@ RULE_MINT5006
@ min spacing of MINT5A to MINT5B 36nm
EXT MINT5A MINT5B < 0.036
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5007{
@ RULE_MINT5007
@ End-of-line spacing of MINT5A to MINT5B (EOL edge defined as edge < 32nm) is 44nm
MINT5A_eol = LENGTH MINT5A < 0.032
MINT5B_eol = LENGTH MINT5B < 0.032
EXT MINT5A_eol MINT5B_eol < 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5008A{
@ RULE_MINT5008A
@ Minimum spacing of MINT5A when MINT5A is wider than 32nm and longer than 240nm is 68nm
MINT5A_wide = MINT5A WITH WIDTH > 0.032
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5A < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5008B{
@ RULE_MINT5008B
@ Minimum spacing of MINT5B when MINT5B is wider than 32nm and longer than 240nm is 68nm
MINT5B_wide = MINT5B WITH WIDTH > 0.032
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5B < 0.068
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5009A{
@ RULE_MINT5009A
@ Minimum spacing of MINT5A when MINT5A is wider than 40nm and longer than 240nm is 76nm
MINT5A_wide = MINT5A WITH WIDTH > 0.040
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5A <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5009B{
@ RULE_MINT5009B
@ Minimum spacing of MINT5B when MINT5B is wider than 40nm and longer than 240nm is 76nm
MINT5B_wide = MINT5B WITH WIDTH > 0.040
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5B <= 0.076
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5010A{
@ RULE_MINT5010A
@ Minimum spacing of MINT5A when MINT5A is wider than 64nm and longer than 480nm is 92nm
MINT5A_wide = MINT5A WITH WIDTH > 0.064
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT5A <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5010B{
@ RULE_MINT5010B
@ Minimum spacing of MINT5B when MINT5B is wider than 64nm and longer than 480nm is 92nm
MINT5B_wide = MINT5B WITH WIDTH > 0.064
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT5B <= 0.092
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5011A{
@ RULE_MINT5011A
@ Minimum spacing of MINT5A when MINT5A is wider than 120nm and longer than 1200nm is 120nm
MINT5A_wide = MINT5A WITH WIDTH > 0.120
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT5A <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5011B{
@ RULE_MINT5011B
@ Minimum spacing of MINT5B when MINT5B is wider than 120nm and longer than 1200nm is 120nm
MINT5B_wide = MINT5B WITH WIDTH > 0.120
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT5B <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5012A{
@ RULE_MINT5012A
@ Minimum spacing of MINT5A when MINT5A is wider than 240nm and longer than 1800nm is 240nm
MINT5A_wide = MINT5A WITH WIDTH > 0.240
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT5A <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5012B{
@ RULE_MINT5012B
@ Minimum spacing of MINT5B when MINT5B is wider than 240nm and longer than 1800nm is 240nm
MINT5B_wide = MINT5B WITH WIDTH > 0.240
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT5B <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5013A{
@ RULE_MINT5013A
@ Minimum spacing of MINT5A when MINT5A is wider than 320nm and longer than 2400nm is 320nm
MINT5A_wide = MINT5A WITH WIDTH > 0.320
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5A <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5013B{
@ RULE_MINT5013B
@ Minimum spacing of MINT5B when MINT5B is wider than 320nm and longer than 2400nm is 320nm
MINT5B_wide = MINT5B WITH WIDTH > 0.320
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5B <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5014A{
@ RULE_MINT5014A
@ Minimum spacing of MINT5A when MINT5A is wider than 600nm and longer than 2400nm is 600nm
MINT5A_wide = MINT5A WITH WIDTH > 0.600
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5A <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5014B{
@ RULE_MINT5014B
@ Minimum spacing of MINT5B when MINT5B is wider than 600nm and longer than 2400nm is 600nm
MINT5B_wide = MINT5B WITH WIDTH > 0.600
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5B <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5015A{
@ RULE_MINT5015A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 32nm and longer than 240nm is 44nm
MINT5B_wide = MINT5B WITH WIDTH > 0.032
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5A <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5015B{
@ RULE_MINT5015B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 32nm and longer than 240nm is 44nm
MINT5A_wide = MINT5A WITH WIDTH > 0.032
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5B <= 0.044
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5016A{
@ RULE_MINT5016A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 40nm and longer than 240nm is 50nm
MINT5B_wide = MINT5B WITH WIDTH > 0.040
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5A <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5016B{
@ RULE_MINT5016B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 40nm and longer than 240nm is 50nm
MINT5A_wide = MINT5A WITH WIDTH > 0.040
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.240
EXT d_p MINT5B <= 0.050
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5017A{
@ RULE_MINT5017A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 64nm and longer than 480nm is 60nm
MINT5B_wide = MINT5B WITH WIDTH > 0.064
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT5A <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5017B{
@ RULE_MINT5017B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 64nm and longer than 480nm is 60nm
MINT5A_wide = MINT5A WITH WIDTH > 0.064
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MINT5B <= 0.060
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5018A{
@ RULE_MINT5018A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 120nm and longer than 1200nm is 78nm
MINT5B_wide = MINT5B WITH WIDTH > 0.120
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT5A <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5018B{
@ RULE_MINT5018B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 120nm and longer than 1200nm is 78nm
MINT5A_wide = MINT5A WITH WIDTH > 0.120
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MINT5B <= 0.078
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5019A{
@ RULE_MINT5019A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 240nm and longer than 1800nm is 156nm
MINT5B_wide = MINT5B WITH WIDTH > 0.240
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT5A <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5019B{
@ RULE_MINT5019B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 240nm and longer than 1800nm is 156nm
MINT5A_wide = MINT5A WITH WIDTH > 0.240
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MINT5B <= 0.156
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5020A{
@ RULE_MINT5020A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 320nm and longer than 2400nm is 200nm
MINT5B_wide = MINT5B WITH WIDTH > 0.320
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5A <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5020B{
@ RULE_MINT5020B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 320nm and longer than 2400nm is 200nm
MINT5A_wide = MINT5A WITH WIDTH > 0.320
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5B <= 0.200
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5021A{
@ RULE_MINT5021A
@ Minimum spacing of MINT5A to MINT5B when MINT5B is wider than 600nm and longer than 2400nm is 400nm
MINT5B_wide = MINT5B WITH WIDTH > 0.600
d = INT MINT5B_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5B_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5A <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5021B{
@ RULE_MINT5021B
@ Minimum spacing of MINT5B to MINT5A when MINT5A is wider than 600nm and longer than 2400nm is 400nm
MINT5A_wide = MINT5A WITH WIDTH > 0.600
d = INT MINT5A_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MINT5A_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MINT5B <= 0.400
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5022{
@ RULE_MINT5022
@ Minimum overlap of MINT5A and MINT5B (stitch region length)
MINT5AB_stitch = MINT5A AND MINT5B
INT MINT5AB_stitch < 0.040
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5023A{
@ RULE_MINT5023A
@ Allowed enclosures of V5 by MINT5A
RECTANGLE ENCLOSURE V5 MINT5A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
// XXX V0 changed to V5
// XXX RECTANGLE ENCLOSURE V5 MINT5A ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V5 MINT5A ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5023B{
@ RULE_MINT5023B
@ Allowed enclosures of V5 by MINT5B
RECTANGLE ENCLOSURE V5 MINT5B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/// XXX V0 changed to V5
// XXX RECTANGLE ENCLOSURE V5 MINT3B ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V5 MINT5B ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5024{
@ RULE_MINT5024
@ Allowed enclosures of V5 by MINT5A-MINT5B stitches
MINT5AB_stitch = MINT5A AND MINT5B
RECTANGLE ENCLOSURE V5 MINT5AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.032 0.002 0.032 0.002
GOOD 0.040 0 0.040 0
GOOD 0.014 0.014 0.014 0.014
}
/// XXX V0 changed to V5
// XXX RECTANGLE ENCLOSURE V5 MINT5AB_stitch ABUT>0<90 SINGULAR OUTSIDE ALSO
// changed to RECTANGLE ENCLOSURE V5 MINT5AB_stitch ABUT>0<90 SINGULAR ORTHOGONAL ONLY
/////////////////////////////////////////////////////////////////////////////////
//RULE_MINT5025A{
//@ RULE_MINT5025A
//@ V5 center must be aligned to wire center (between 2 longest edges)
//V5_MINT5A_OVERLAP =  V5 AND MINT5A
//// deriving metal and via edge pairs
//MINT5A_edges = INT MINT5A < 1
//V5_edges = INT V5 < 1
//// deriving metal and via center lines
//MINT5A_centerline = DFM COPY MINT5A_edges CENTERLINE
//V5_centerline = DFM COPY V5_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT5A_centerline COIN EDGE V5_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V5_MINT5A_OVERLAP NOT INTERACT y
//}
//// XXX V5 NOT INTERACT y 
//// changed to V5_MINT5A_OVERLAP NOT INTERACT y 
//// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
///////////////////////////////////////////////////////////////////////////////////
//RULE_MINT5025B{
//@ RULE_MINT5025B
//@ V5 center must be aligned to wire center (between 2 longest edges)
//V5_MINT5B_OVERLAP = V5 AND MINT5B
//// deriving metal and via edge pairs
//MINT5B_edges = INT MINT5B < 1
//V5_edges = INT V5 < 1
//// deriving metal and via center lines
//MINT5B_centerline = DFM COPY MINT5B_edges CENTERLINE
//V5_centerline = DFM COPY V5_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MINT5B_centerline COIN EDGE V5_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V5_MINT5B_OVERLAP NOT INTERACT y
//}
// XXX V5 NOT INTERACT y 
// changed to V5_MINT5B_OVERLAP NOT INTERACT y 
// This issue doesn't solve the issue completely. It doesn't detect errors if the centerline is off by 1nm.
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5026A{
@ RULE_MINT5026A
@ V5 shape must be rectangular if enclosing MINT5A wire width >= 60nm
wide_MINT5A = MINT5A WITH WIDTH >= 0.060
V5_in_wideMINT5A = V5 INSIDE wide_MINT5A
NOT RECTANGLE V5_in_wideMINT5A
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5026B{
@ RULE_MINT5026B
@ V5 shape must be rectangular if enclosing MINT5B wire width >= 60nm
wide_MINT5B = MINT5B WITH WIDTH >= 0.060
V5_in_wideMINT5B = V5 INSIDE wide_MINT5B
NOT RECTANGLE V5_in_wideMINT5B
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MINT5027A{
@ RULE_MINT5027A
@ MINT5A minimum area for rectangular shape is 0.0024um2
rect_MINT5A = RECTANGLE MINT5A
AREA rect_MINT5A < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT5027B{
@ RULE_MINT5027B
@ MINT5B minimum area for rectangular shape is 0.0024um2
rect_MINT5B = RECTANGLE MINT5B
AREA rect_MINT5B < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT5028A{
@ RULE_MINT5028A
@ MINT5A min area for non-rectangular shape is 0.0036um2
no_rect_MINT5A = NOT RECTANGLE MINT5A
AREA no_rect_MINT5A < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
RULE_MINT5028B{
@ RULE_MINT5028B
@ MINT5B min area for non-rectangular shape is 0.0036um2
no_rect_MINT5B = NOT RECTANGLE MINT5B
AREA no_rect_MINT5B < 0.0036
}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT5029A{
//@ RULE_MINT5029A
//@ MINT5A preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT5A
//vert_edges = MINT5A ANGLE == 90
//hor_edges = MINT5A ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT5A hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////
//RULE_MINT5029B{
//@ RULE_MINT5029B
//@ MINT5B preferred routing direction is vertical (all polygons should be vertical)
//derive horizontal and vertical edges of MINT5A
//vert_edges = MINT5B ANGLE == 90
//hor_edges = MINT5B ANGLE == 0
//derive horizontal and vertical spacings, 10 is a large arbitrary contstraint just
//to include all spacings
//vert_edges_int = INT vert_edges < 10
//hor_edges_int = INT hor_edges < 10
//derive horizontal polygons through dfm property by comparing the horizontal and vertical spacings on the same polygon
//to decide whether this polygon is horizontal or vertical. if horizontal spacing is larger than vertical spacing then this polygon is
//horizontally oriented.
//hor_polygons = DFM PROPERTY MINT5B hor_edges_int vert_edges_int OVERLAP MULTI [check2 = EW(vert_edges_int) - EW(hor_edges_int)] > 0
//output horizontal polygons
//COPY hor_polygons
//}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ VSMG1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1001a{
@ RULE_VSMG1001a
@ VSMG1 is a square with 56nm edge length
RECTANGLE VSMG1 != 0.056 BY != 0.056 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1001b{
@ RULE_VSMG1001b
@ VSMG1 is a rectangle 56nm x 112nm when enclosed in MSMG1 with width >= 120nm
wide_MSMG1 = MSMG1 WITH WIDTH >= 0.120
VSMG1_wide_MSMG1 = VSMG1 INSIDE wide_MSMG1
RECTANGLE VSMG1_wide_MSMG1 != 0.112 BY != 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1001c{
@ RULE_VSMG1001c
@ VSMG1 is a rectangle 56nm x 112nm when enclosed in MSMG2 with width >= 120nm
wide_MSMG2 = MSMG2 WITH WIDTH >= 0.120
VSMG1_wide_MSMG2 = VSMG1 INSIDE wide_MSMG2
RECTANGLE VSMG1_wide_MSMG2 != 0.112 BY != 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1002{
 @ RULE_VSMG1002
 @ Minimum spacing of VSMG1 if runlength exactly = 56nm is 72nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 MSMG1_MSMG2 = MSMG1 AND MSMG2
 // deriving edges of the intersection
 MSMG1_MSMG2_EDGES = ANGLE MSMG1_MSMG2 == 90
 // identifying edges with runlength = 28nm
 MSMG1_MSMG2_EDGES_LENGTH = PATH LENGTH MSMG1_MSMG2_EDGES == 0.056
 // forming polygons out of those edges
 MSMG1_MSMG2_polygons = MSMG1 WITH EDGE MSMG1_MSMG2_EDGES_LENGTH
 // finding VSMG1 that interact with the formed polygons
 VSMG1_MSMG1_MSMG2 = VSMG1 INTERACT MSMG1_MSMG2_polygons
 // Finding spacing
 EXT VSMG1_MSMG1_MSMG2 < 0.072
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1003{
 @ RULE_VSMG1003
 @ Minimum spacing of VSMG1 if runlength < 56nm is 100nm
 // assuming runlength is the common length between M1 and MINT1, and M1 is vertical 
 MSMG1_MSMG2 = MSMG1 AND MSMG2
 // deriving edges of the intersection
 MSMG1_MSMG2_EDGES = ANGLE MSMG1_MSMG2 == 90
 // identifying edges with runlength < 56nm
 MSMG1_MSMG2_EDGES_LENGTH = PATH LENGTH MSMG1_MSMG2_EDGES < 0.056
 // forming polygons out of those edges
 MSMG1_MSMG2_polygons = MSMG1 WITH EDGE MSMG1_MSMG2_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 VSMG1_MSMG1_MSMG2 = VSMG1 INTERACT MSMG1_MSMG2_polygons
 // Finding spacing
 EXT VSMG1_MSMG1_MSMG2 < 0.100
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1004{
@ RULE_VSMG1004
@ VSMG1 must be inside (MSMG1 and MSMG2)
layer_intersections = MSMG1 AND MSMG2 
VSMG1 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VSMG1005{
@ RULE_VSMG1005
@ VSMG1 shape must be rectangular if enclosing MSMG1 wire width >= 120nm
wide_MSMG1 = MSMG1 WITH WIDTH >= 0.120
VSMG1_in_wideMSMG1 = VSMG1 INSIDE wide_MSMG1
NOT RECTANGLE VSMG1_in_wideMSMG1
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ VSMG2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2001a{
@ RULE_VSMG2001a
@ VSMG2 is a square with 56nm edge length
RECTANGLE VSMG2 != 0.056 BY != 0.056 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2001b{
@ RULE_VSMG2001b
@ VSMG2 is a rectangle 56nm x 112nm when enclosed in MSMG2 with width >= 120nm
wide_MSMG2 = MSMG2 WITH WIDTH >= 0.120
VSMG2_wide_MSMG2 = VSMG2 INSIDE wide_MSMG2
RECTANGLE VSMG2_wide_MSMG2 != 0.112 BY != 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2001c{
@ RULE_VSMG2001c
@ VSMG2 is a rectangle 56nm x 112nm when enclosed in MSMG2 with width >= 120nm
wide_MSMG2 = MSMG2 WITH WIDTH >= 0.120
VSMG2_wide_MSMG2 = VSMG2 INSIDE wide_MSMG2
RECTANGLE VSMG2_wide_MSMG2 != 0.112 BY != 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2002{
 @ RULE_VSMG2002
 @ Minimum spacing of VSMG2 if runlength exactly = 56nm is 72nm
 MSMG2_MSMG3 = MSMG2 AND MSMG3
 // deriving edges of the intersection
 MSMG2_MSMG3_EDGES = ANGLE MSMG2_MSMG3 == 90
 // identifying edges with runlength = 28nm
 MSMG2_MSMG3_EDGES_LENGTH = PATH LENGTH MSMG2_MSMG3_EDGES == 0.056
 // forming polygons out of those edges
 MSMG2_MSMG3_polygons = MSMG2 WITH EDGE MSMG2_MSMG3_EDGES_LENGTH
 // finding VSMG2 that interact with the formed polygons
 VSMG2_MSMG2_MSMG3 = VSMG2 INTERACT MSMG2_MSMG3_polygons
 // Finding spacing
 EXT VSMG2_MSMG2_MSMG3 < 0.072
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2003{
 @ RULE_VSMG2003
 @ Minimum spacing of VSMG2 if runlength < 56nm is 100nm
 MSMG2_MSMG3 = MSMG2 AND MSMG3
 // deriving edges of the intersection
 MSMG2_MSMG3_EDGES = ANGLE MSMG2_MSMG3 == 90
 // identifying edges with runlength < 56nm
 MSMG2_MSMG3_EDGES_LENGTH = PATH LENGTH MSMG2_MSMG3_EDGES < 0.056
 // forming polygons out of those edges
 MSMG2_MSMG3_polygons = MSMG2 WITH EDGE MSMG2_MSMG3_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 VSMG2_MSMG2_MSMG3 = VSMG2 INTERACT MSMG2_MSMG3_polygons
 // Finding spacing
 EXT VSMG2_MSMG2_MSMG3 < 0.100
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2004{
@ RULE_VSMG2004
@ VSMG2 must be inside (MSMG2 and MSMG3)
layer_intersections = MSMG2 AND MSMG3 
VSMG2 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VSMG2005{
@ RULE_VSMG2005
@ VSMG2 shape must be rectangular if enclosing MSMG2 wire width >= 120nm
wide_MSMG2 = MSMG2 WITH WIDTH >= 0.120
VSMG2_in_wideMSMG2 = VSMG2 INSIDE wide_MSMG2
NOT RECTANGLE VSMG2_in_wideMSMG2
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ VSMG3 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3001a{
@ RULE_VSMG3001a
@ VSMG3 is a square with 56nm edge length
RECTANGLE VSMG3 != 0.056 BY != 0.056 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3001b{
@ RULE_VSMG3001b
@ VSMG3 is a rectangle 56nm x 112nm when enclosed in MSMG3 with width >= 120nm
wide_MSMG3 = MSMG3 WITH WIDTH >= 0.120
VSMG3_wide_MSMG3 = VSMG3 INSIDE wide_MSMG3
RECTANGLE VSMG3_wide_MSMG3 != 0.112 BY != 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3001c{
@ RULE_VSMG3001c
@ VSMG3 is a rectangle 56nm x 112nm when enclosed in MSMG3 with width >= 120nm
wide_MSMG3 = MSMG3 WITH WIDTH >= 0.120
VSMG3_wide_MSMG3 = VSMG3 INSIDE wide_MSMG3
RECTANGLE VSMG3_wide_MSMG3 != 0.112 BY != 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3002{
 @ RULE_VSMG3002
 @ Minimum spacing of VSMG3 if runlength exactly = 56nm is 72nm
 MSMG3_MSMG4 = MSMG3 AND MSMG4
 // deriving edges of the intersection
 MSMG3_MSMG4_EDGES = ANGLE MSMG3_MSMG4 == 90
 // identifying edges with runlength = 28nm
 MSMG3_MSMG4_EDGES_LENGTH = PATH LENGTH MSMG3_MSMG4_EDGES == 0.056
 // forming polygons out of those edges
 MSMG3_MSMG4_polygons = MSMG3 WITH EDGE MSMG3_MSMG4_EDGES_LENGTH
 // finding VSMG2 that interact with the formed polygons
 VSMG3_MSMG3_MSMG4 = VSMG3 INTERACT MSMG3_MSMG4_polygons
 // Finding spacing
 EXT VSMG3_MSMG3_MSMG4 < 0.072
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3003{
 @ RULE_VSMG3003
 @ Minimum spacing of VSMG3 if runlength < 56nm is 100nm
 MSMG3_MSMG4 = MSMG3 AND MSMG4
 // deriving edges of the intersection
 MSMG3_MSMG4_EDGES = ANGLE MSMG3_MSMG4 == 90
 // identifying edges with runlength < 56nm
 MSMG3_MSMG4_EDGES_LENGTH = PATH LENGTH MSMG3_MSMG4_EDGES < 0.056
 // forming polygons out of those edges
 MSMG3_MSMG4_polygons = MSMG3 WITH EDGE MSMG3_MSMG4_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 VSMG3_MSMG3_MSMG4 = VSMG3 INTERACT MSMG3_MSMG4_polygons
 // Finding spacing
 EXT VSMG3_MSMG3_MSMG4 < 0.100
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3004{
@ RULE_VSMG3004
@ VSMG3 must be inside (MSMG3 and MSMG4)
layer_intersections = MSMG3 AND MSMG4 
VSMG3 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VSMG3005{
@ RULE_VSMG3005
@ VSMG3 shape must be rectangular if enclosing MSMG3 wire width >= 120nm
wide_MSMG3 = MSMG3 WITH WIDTH >= 0.120
VSMG3_in_wideMSMG3 = VSMG3 INSIDE wide_MSMG3
NOT RECTANGLE VSMG3_in_wideMSMG3
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ VSMG4 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4001a{
@ RULE_VSMG4001a
@ VSMG4 is a square with 56nm edge length
RECTANGLE VSMG4 != 0.056 BY != 0.056 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4001b{
@ RULE_VSMG4001b
@ VSMG4 is a rectangle 56nm x 112nm when enclosed in MSMG4 with width >= 120nm
wide_MSMG4 = MSMG4 WITH WIDTH >= 0.120
VSMG4_wide_MSMG4 = VSMG4 INSIDE wide_MSMG4
RECTANGLE VSMG4_wide_MSMG4 != 0.112 BY != 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4001c{
@ RULE_VSMG4001c
@ VSMG4 is a rectangle 56nm x 112nm when enclosed in MSMG4 with width >= 120nm
wide_MSMG4 = MSMG4 WITH WIDTH >= 0.120
VSMG4_wide_MSMG4 = VSMG4 INSIDE wide_MSMG4
RECTANGLE VSMG4_wide_MSMG4 != 0.112 BY != 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4002{
 @ RULE_VSMG4002
 @ Minimum spacing of VSMG4 if runlength exactly = 56nm is 72nm
 MSMG4_MSMG5 = MSMG4 AND MSMG5
 // deriving edges of the intersection
 MSMG4_MSMG5_EDGES = ANGLE MSMG4_MSMG5 == 90
 // identifying edges with runlength = 28nm
 MSMG4_MSMG5_EDGES_LENGTH = PATH LENGTH MSMG4_MSMG5_EDGES == 0.056
 // forming polygons out of those edges
 MSMG4_MSMG5_polygons = MSMG4 WITH EDGE MSMG4_MSMG5_EDGES_LENGTH
 // finding VSMG2 that interact with the formed polygons
 VSMG4_MSMG4_MSMG5 = VSMG4 INTERACT MSMG4_MSMG5_polygons
 // Finding spacing
 EXT VSMG4_MSMG4_MSMG5 < 0.072
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4003{
 @ RULE_VSMG4003
 @ Minimum spacing of VSMG4 if runlength < 56nm is 100nm
 MSMG4_MSMG5 = MSMG4 AND MSMG5
 // deriving edges of the intersection
 MSMG4_MSMG5_EDGES = ANGLE MSMG4_MSMG5 == 90
 // identifying edges with runlength < 56nm
 MSMG4_MSMG5_EDGES_LENGTH = PATH LENGTH MSMG4_MSMG5_EDGES < 0.056
 // forming polygons out of those edges
 MSMG4_MSMG5_polygons = MSMG4 WITH EDGE MSMG4_MSMG5_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 VSMG4_MSMG4_MSMG5 = VSMG4 INTERACT MSMG4_MSMG5_polygons
 // Finding spacing
 EXT VSMG4_MSMG4_MSMG5 < 0.100
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4004{
@ RULE_VSMG4004
@ VSMG4 must be inside (MSMG4 and MSMG5)
layer_intersections = MSMG4 AND MSMG5 
VSMG4 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VSMG4005{
@ RULE_VSMG4005
@ VSMG4 shape must be rectangular if enclosing MSMG4 wire width >= 120nm
wide_MSMG4 = MSMG4 WITH WIDTH >= 0.120
VSMG4_in_wideMSMG4 = VSMG4 INSIDE wide_MSMG4
NOT RECTANGLE VSMG4_in_wideMSMG4
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ VSMG5 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5001a{
@ RULE_VSMG5001a
@ VSMG5 is a square with 56nm edge length
RECTANGLE VSMG5 != 0.056 BY != 0.056 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5001b{
@ RULE_VSMG5001b
@ VSMG5 is a rectangle 56nm x 112nm when enclosed in MSMG5 with width >= 120nm
wide_MSMG5 = MSMG5 WITH WIDTH >= 0.120
VSMG5_wide_MSMG5 = VSMG5 INSIDE wide_MSMG5
RECTANGLE VSMG5_wide_MSMG5 != 0.112 BY != 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5001c{
@ RULE_VSMG5001c
@ VSMG5 is a rectangle 56nm x 112nm when enclosed in MSMG5 with width >= 120nm
wide_MSMG5 = MSMG5 WITH WIDTH >= 0.120
VSMG5_wide_MSMG5 = VSMG5 INSIDE wide_MSMG5
RECTANGLE VSMG5_wide_MSMG5 != 0.112 BY != 0.056
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5002{
 @ RULE_VSMG5002
 @ Minimum spacing of VSMG5 if runlength exactly = 56nm is 72nm
 MSMG5_MG1 = MSMG5 AND MG1
 // deriving edges of the intersection
 MSMG5_MG1_EDGES = ANGLE MSMG5_MG1 == 90
 // identifying edges with runlength = 28nm
 MSMG5_MG1_EDGES_LENGTH = PATH LENGTH MSMG5_MG1_EDGES == 0.056
 // forming polygons out of those edges
 MSMG5_MG1_polygons = MSMG5 WITH EDGE MSMG5_MG1_EDGES_LENGTH
 // finding VSMG2 that interact with the formed polygons
 VSMG5_MSMG5_MG1 = VSMG5 INTERACT MSMG5_MG1_polygons
 // Finding spacing
 EXT VSMG5_MSMG5_MG1 < 0.072
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5003{
 @ RULE_VSMG5003
 @ Minimum spacing of VSMG5 if runlength < 56nm is 100nm
 MSMG5_MG1 = MSMG5 AND MG1
 // deriving edges of the intersection
 MSMG5_MG1_EDGES = ANGLE MSMG5_MG1 == 90
 // identifying edges with runlength < 56nm
 MSMG5_MG1_EDGES_LENGTH = PATH LENGTH MSMG5_MG1_EDGES < 0.056
 // forming polygons out of those edges
 MSMG5_MG1_polygons = MSMG5 WITH EDGE MSMG5_MG1_EDGES_LENGTH
 // finding V1 that interact with the formed polygons
 VSMG5_MSMG5_MG1 = VSMG5 INTERACT MSMG5_MG1_polygons
 // Finding spacing
 EXT VSMG5_MSMG5_MG1 < 0.100
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5004{
@ RULE_VSMG5004
@ VSMG5 must be inside (MSMG5 and MG1)
layer_intersections = MSMG5 AND MG1 
VSMG5 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VSMG5005{
@ RULE_VSMG5005
@ VSMG5 shape must be rectangular if enclosing MSMG5 wire width >= 120nm
wide_MSMG5 = MSMG5 WITH WIDTH >= 0.120
VSMG5_in_wideMSMG5 = VSMG5 INSIDE wide_MSMG5
NOT RECTANGLE VSMG5_in_wideMSMG5
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________ MSMG1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1001{
@ RULE_MSMG1001
@ MSMG1 width > 56nm
INTERNAL MSMG1 < 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1002{
@ RULE_MSMG1002
@ One of two edges connected to the same vertex must have at least one of 112nm
x = CONVEX EDGE MSMG1 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.112
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1003{
@ RULE_MSMG1003
@ maximum length of MSMG1 for wires with min width 56nm is 1.92um
wide_MSMG1 = MSMG1 with width >= 0.056
d = INT wide_MSMG1 <= 1 opposite
d_p = dfm property wide_MSMG1 d overlap abut also [EC1 = EC(d)] > 1.920
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1004{
@ RULE_MSMG1004
@ MSMG1 end-of-line spacing (end-of-line edge defined as edge < 64nm) is 136nm
MSMG1_eol = LENGTH MSMG1 < 0.064
EXT MSMG1_eol < 0.136
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1005{
@ RULE_MSMG1005
@ MSMG1 min space and notch 56nm
EXT MSMG1 < 0.056 NOTCH
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1006{
@ RULE_MSMG1006
@ Minimum spacing of MSMG1 when MSMG1 is wider than 64nm and longer than 480nm is 92nm
MSMG1_wide = MSMG1 WITH WIDTH > 0.064
d = INT MSMG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MSMG1 <= 0.092
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1007{
@ RULE_MSMG1007
@ Minimum spacing of MSMG1 when MSMG1 is wider than 120nm and longer than 1200nm is 120nm
MSMG1_wide = MSMG1 WITH WIDTH > 0.120
d = INT MSMG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MSMG1 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1008{
@ RULE_MSMG1008
@ Minimum spacing of MSMG1 when MSMG1 is wider than 240nm and longer than 1800nm is 240nm
MSMG1_wide = MSMG1 WITH WIDTH > 0.240
d = INT MSMG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MSMG1 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1009{
@ RULE_MSMG1009
@ Minimum spacing of MSMG1 when MSMG1 is wider than 320nm and longer than 2400nm is 320nm
MSMG1_wide = MSMG1 WITH WIDTH > 0.320
d = INT MSMG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG1 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1010{
@ RULE_MSMG1010
@ Minimum spacing of MSMG1 when MSMG1 is wider than 600nm and longer than 2400nm is 600nm
MSMG1_wide = MSMG1 WITH WIDTH > 0.600
d = INT MSMG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG1 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1011{
@ RULE_MSMG1011
@ Allowed enclosures of V6 by MSMG1
RECTANGLE ENCLOSURE V6 MSMG1 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MSMG1012{
//@ RULE_MSMG1012
//@ V6 center must be aligned to wire center (between 2 longest edges)
//V6_MSMG1_OVERLAP =  V6 AND MSMG1
//// deriving metal and via edge pairs
//MSMG1_edges = INT MSMG1 < 1
//V6_edges = INT V6 < 1
//// deriving metal and via center lines
//MSMG1_centerline = DFM COPY MSMG1_edges CENTERLINE
//V6_centerline = DFM COPY V6_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MSMG1_centerline COIN EDGE V6_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//V6_MSMG1_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1013{
@ RULE_MSMG1013
@ V6 shape must be rectangular if enclosing MSMG1 wire width >= 120nm
wide_MSMG1 = MSMG1 WITH WIDTH >= 0.120
V6_in_wideMSMG1 = V6 INSIDE wide_MSMG1
NOT RECTANGLE V6_in_wideMSMG1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1014{
@ RULE_MSMG1014
@ MSMG1 minimum area for rectangular shape is 0.0024um2
rect_MSMG1 = RECTANGLE MSMG1
AREA rect_MSMG1 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MSMG1015{
@ RULE_MSMG1015
@ MSMG1 min area for non-rectangular shape is 0.0036um2
no_rect_MSMG1 = NOT RECTANGLE MSMG1
AREA no_rect_MSMG1 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________MSMG2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2001{
@ RULE_MSMG2001
@ MSMG2 width > 56nm
INTERNAL MSMG2 < 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2002{
@ RULE_MSMG2002
@ One of two edges connected to the same vertex must have at least one of 112nm
x = CONVEX EDGE MSMG2 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.112
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2003{
@ RULE_MSMG2003
@ maximum length of MSMG2 for wires with min width 56nm is 1.92um
wide_MSMG2 = MSMG2 with width >= 0.056
d = INT wide_MSMG2 <= 1 opposite
d_p = dfm property wide_MSMG2 d overlap abut also [EC1 = EC(d)] > 1.920
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2004{
@ RULE_MSMG2004
@ MSMG2 end-of-line spacing (end-of-line edge defined as edge < 64nm) is 136nm
MSMG2_eol = LENGTH MSMG2 < 0.064
EXT MSMG2_eol < 0.136
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2005{
@ RULE_MSMG2005
@ MSMG2 min space and notch 56nm
EXT MSMG2 < 0.056 NOTCH
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2006{
@ RULE_MSMG2006
@ Minimum spacing of MSMG2 when MSMG2 is wider than 64nm and longer than 480nm is 92nm
MSMG2_wide = MSMG2 WITH WIDTH > 0.064
d = INT MSMG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MSMG2 <= 0.092
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2007{
@ RULE_MSMG2007
@ Minimum spacing of MSMG2 when MSMG2 is wider than 120nm and longer than 1200nm is 120nm
MSMG2_wide = MSMG2 WITH WIDTH > 0.120
d = INT MSMG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MSMG2 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2008{
@ RULE_MSMG2008
@ Minimum spacing of MSMG2 when MSMG2 is wider than 240nm and longer than 1800nm is 240nm
MSMG2_wide = MSMG2 WITH WIDTH > 0.240
d = INT MSMG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MSMG2 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2009{
@ RULE_MSMG2009
@ Minimum spacing of MSMG2 when MSMG2 is wider than 320nm and longer than 2400nm is 320nm
MSMG2_wide = MSMG2 WITH WIDTH > 0.320
d = INT MSMG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG2 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2010{
@ RULE_MSMG2010
@ Minimum spacing of MSMG2 when MSMG2 is wider than 600nm and longer than 2400nm is 600nm
MSMG2_wide = MSMG2 WITH WIDTH > 0.600
d = INT MSMG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG2 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2011{
@ RULE_MSMG2011
@ Allowed enclosures of VSMG1 by MSMG2
RECTANGLE ENCLOSURE VSMG1 MSMG2 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MSMG2012{
//@ RULE_MSMG2012
//@ VSMG1 center must be aligned to wire center (between 2 longest edges)
//VSMG1_MSMG2_OVERLAP =  VSMG1 AND MSMG2
//// deriving metal and via edge pairs
//MSMG2_edges = INT MSMG2 < 1
//VSMG1_edges = INT VSMG1 < 1
//// deriving metal and via center lines
//MSMG2_centerline = DFM COPY MSMG2_edges CENTERLINE
//VSMG1_centerline = DFM COPY VSMG1_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MSMG2_centerline COIN EDGE VSMG1_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VSMG1_MSMG2_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2013{
@ RULE_MSMG2013
@ VSMG1 shape must be rectangular if enclosing MSMG2 wire width >= 120nm
wide_MSMG2 = MSMG2 WITH WIDTH >= 0.120
VSMG1_in_wideMSMG2 = VSMG1 INSIDE wide_MSMG2
NOT RECTANGLE VSMG1_in_wideMSMG2
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2014{
@ RULE_MSMG2014
@ MSMG2 minimum area for rectangular shape is 0.0024um2
rect_MSMG2 = RECTANGLE MSMG2
AREA rect_MSMG2 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MSMG2015{
@ RULE_MSMG2015
@ MSMG2 min area for non-rectangular shape is 0.0036um2
no_rect_MSMG2 = NOT RECTANGLE MSMG2
AREA no_rect_MSMG2 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________MSMG3 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3001{
@ RULE_MSMG3001
@ MSMG3 width > 56nm
INTERNAL MSMG3 < 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3002{
@ RULE_MSMG3002
@ One of two edges connected to the same vertex must have at least one of 112nm
x = CONVEX EDGE MSMG3 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.112
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3003{
@ RULE_MSMG3003
@ maximum length of MSMG3 for wires with min width 56nm is 1.92um
wide_MSMG3 = MSMG3 with width >= 0.056
d = INT wide_MSMG3 <= 1 opposite
d_p = dfm property wide_MSMG3 d overlap abut also [EC1 = EC(d)] > 1.920
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3004{
@ RULE_MSMG3004
@ MSMG3 end-of-line spacing (end-of-line edge defined as edge < 64nm) is 136nm
MSMG3_eol = LENGTH MSMG3 < 0.064
EXT MSMG3_eol < 0.136
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3005{
@ RULE_MSMG3005
@ MSMG3 min space and notch 56nm
EXT MSMG3 < 0.056 NOTCH
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3006{
@ RULE_MSMG3006
@ Minimum spacing of MSMG3 when MSMG3 is wider than 64nm and longer than 480nm is 92nm
MSMG3_wide = MSMG3 WITH WIDTH > 0.064
d = INT MSMG3_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG3_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MSMG3 <= 0.092
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3007{
@ RULE_MSMG3007
@ Minimum spacing of MSMG3 when MSMG3 is wider than 120nm and longer than 1200nm is 120nm
MSMG3_wide = MSMG3 WITH WIDTH > 0.120
d = INT MSMG3_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG3_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MSMG3 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3008{
@ RULE_MSMG3008
@ Minimum spacing of MSMG3 when MSMG3 is wider than 240nm and longer than 1800nm is 240nm
MSMG3_wide = MSMG3 WITH WIDTH > 0.240
d = INT MSMG3_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG3_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MSMG3 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3009{
@ RULE_MSMG3009
@ Minimum spacing of MSMG3 when MSMG3 is wider than 320nm and longer than 2400nm is 320nm
MSMG3_wide = MSMG3 WITH WIDTH > 0.320
d = INT MSMG3_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG3_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG3 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3010{
@ RULE_MSMG3010
@ Minimum spacing of MSMG3 when MSMG3 is wider than 600nm and longer than 2400nm is 600nm
MSMG3_wide = MSMG3 WITH WIDTH > 0.600
d = INT MSMG3_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG3_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG3 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3011{
@ RULE_MSMG3011
@ Allowed enclosures of VSMG2 by MSMG3
RECTANGLE ENCLOSURE VSMG2 MSMG3 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MSMG3012{
//@ RULE_MSMG3012
//@ VSMG2 center must be aligned to wire center (between 2 longest edges)
//VSMG2_MSMG3_OVERLAP =  VSMG2 AND MSMG3
//// deriving metal and via edge pairs
//MSMG3_edges = INT MSMG3 < 1
//VSMG2_edges = INT VSMG2 < 1
//// deriving metal and via center lines
//MSMG3_centerline = DFM COPY MSMG3_edges CENTERLINE
//VSMG2_centerline = DFM COPY VSMG2_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MSMG3_centerline COIN EDGE VSMG2_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VSMG2_MSMG3_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3013{
@ RULE_MSMG3013
@ VSMG2 shape must be rectangular if enclosing MSMG3 wire width >= 120nm
wide_MSMG3 = MSMG3 WITH WIDTH >= 0.120
VSMG2_in_wideMSMG3 = VSMG2 INSIDE wide_MSMG3
NOT RECTANGLE VSMG2_in_wideMSMG3
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3014{
@ RULE_MSMG3014
@ MSMG3 minimum area for rectangular shape is 0.0024um2
rect_MSMG3 = RECTANGLE MSMG3
AREA rect_MSMG3 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MSMG3015{
@ RULE_MSMG3015
@ MSMG3 min area for non-rectangular shape is 0.0036um2
no_rect_MSMG3 = NOT RECTANGLE MSMG3
AREA no_rect_MSMG3 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________MSMG4 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4001{
@ RULE_MSMG4001
@ MSMG4 width > 56nm
INTERNAL MSMG4 < 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4002{
@ RULE_MSMG4002
@ One of two edges connected to the same vertex must have at least one of 112nm
x = CONVEX EDGE MSMG4 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.112
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4003{
@ RULE_MSMG4003
@ maximum length of MSMG4 for wires with min width 56nm is 1.92um
wide_MSMG4 = MSMG4 with width >= 0.056
d = INT wide_MSMG4 <= 1 opposite
d_p = dfm property wide_MSMG4 d overlap abut also [EC1 = EC(d)] > 1.920
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4004{
@ RULE_MSMG4004
@ MSMG4 end-of-line spacing (end-of-line edge defined as edge < 64nm) is 136nm
MSMG4_eol = LENGTH MSMG4 < 0.064
EXT MSMG4_eol < 0.136
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4005{
@ RULE_MSMG4005
@ MSMG4 min space and notch 56nm
EXT MSMG4 < 0.056 NOTCH
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4006{
@ RULE_MSMG4006
@ Minimum spacing of MSMG4 when MSMG4 is wider than 64nm and longer than 480nm is 92nm
MSMG4_wide = MSMG4 WITH WIDTH > 0.064
d = INT MSMG4_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG4_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MSMG4 <= 0.092
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4007{
@ RULE_MSMG4007
@ Minimum spacing of MSMG4 when MSMG4 is wider than 120nm and longer than 1200nm is 120nm
MSMG4_wide = MSMG4 WITH WIDTH > 0.120
d = INT MSMG4_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG4_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MSMG4 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4008{
@ RULE_MSMG4008
@ Minimum spacing of MSMG4 when MSMG4 is wider than 240nm and longer than 1800nm is 240nm
MSMG4_wide = MSMG4 WITH WIDTH > 0.240
d = INT MSMG4_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG4_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MSMG4 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4009{
@ RULE_MSMG4009
@ Minimum spacing of MSMG4 when MSMG4 is wider than 320nm and longer than 2400nm is 320nm
MSMG4_wide = MSMG4 WITH WIDTH > 0.320
d = INT MSMG4_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG4_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG4 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4010{
@ RULE_MSMG4010
@ Minimum spacing of MSMG4 when MSMG4 is wider than 600nm and longer than 2400nm is 600nm
MSMG4_wide = MSMG4 WITH WIDTH > 0.600
d = INT MSMG4_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG4_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG4 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4011{
@ RULE_MSMG4011
@ Allowed enclosures of VSMG3 by MSMG4
RECTANGLE ENCLOSURE VSMG3 MSMG4 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MSMG4012{
//@ RULE_MSMG4012
//@ VSMG3 center must be aligned to wire center (between 2 longest edges)
//VSMG3_MSMG4_OVERLAP =  VSMG3 AND MSMG4
//// deriving metal and via edge pairs
//MSMG4_edges = INT MSMG4 < 1
//VSMG3_edges = INT VSMG3 < 1
//// deriving metal and via center lines
//MSMG4_centerline = DFM COPY MSMG4_edges CENTERLINE
//VSMG3_centerline = DFM COPY VSMG3_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MSMG4_centerline COIN EDGE VSMG3_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VSMG3_MSMG4_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4013{
@ RULE_MSMG4013
@ VSMG3 shape must be rectangular if enclosing MSMG4 wire width >= 120nm
wide_MSMG4 = MSMG4 WITH WIDTH >= 0.120
VSMG3_in_wideMSMG4 = VSMG3 INSIDE wide_MSMG4
NOT RECTANGLE VSMG3_in_wideMSMG4
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4014{
@ RULE_MSMG4014
@ MSMG4 minimum area for rectangular shape is 0.0024um2
rect_MSMG4 = RECTANGLE MSMG4
AREA rect_MSMG4 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MSMG4015{
@ RULE_MSMG4015
@ MSMG4 min area for non-rectangular shape is 0.0036um2
no_rect_MSMG4 = NOT RECTANGLE MSMG4
AREA no_rect_MSMG4 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//____________________________________________________________________MSMG5 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5001{
@ RULE_MSMG5001
@ MSMG5 width > 56nm
INTERNAL MSMG5 < 0.056
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5002{
@ RULE_MSMG5002
@ One of two edges connected to the same vertex must have at least one of 112nm
x = CONVEX EDGE MSMG5 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.112
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5003{
@ RULE_MSMG5003
@ maximum length of MSMG5 for wires with min width 56nm is 1.92um
wide_MSMG5 = MSMG5 with width >= 0.056
d = INT wide_MSMG5 <= 1 opposite
d_p = dfm property wide_MSMG5 d overlap abut also [EC1 = EC(d)] > 1.920
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5004{
@ RULE_MSMG5004
@ MSMG5 end-of-line spacing (end-of-line edge defined as edge < 64nm) is 136nm
MSMG5_eol = LENGTH MSMG5 < 0.064
EXT MSMG5_eol < 0.136
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5005{
@ RULE_MSMG5005
@ MSMG5 min space and notch 56nm
EXT MSMG5 < 0.056 NOTCH
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5006{
@ RULE_MSMG5006
@ Minimum spacing of MSMG5 when MSMG5 is wider than 64nm and longer than 480nm is 92nm
MSMG5_wide = MSMG5 WITH WIDTH > 0.064
d = INT MSMG5_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG5_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 0.480
EXT d_p MSMG5 <= 0.092
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5007{
@ RULE_MSMG5007
@ Minimum spacing of MSMG5 when MSMG5 is wider than 120nm and longer than 1200nm is 120nm
MSMG5_wide = MSMG5 WITH WIDTH > 0.120
d = INT MSMG5_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG5_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MSMG5 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5008{
@ RULE_MSMG5008
@ Minimum spacing of MSMG5 when MSMG5 is wider than 240nm and longer than 1800nm is 240nm
MSMG5_wide = MSMG5 WITH WIDTH > 0.240
d = INT MSMG5_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG5_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MSMG5 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5009{
@ RULE_MSMG5009
@ Minimum spacing of MSMG5 when MSMG5 is wider than 320nm and longer than 2400nm is 320nm
MSMG5_wide = MSMG5 WITH WIDTH > 0.320
d = INT MSMG5_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG5_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG5 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5010{
@ RULE_MSMG5010
@ Minimum spacing of MSMG5 when MSMG5 is wider than 600nm and longer than 2400nm is 600nm
MSMG5_wide = MSMG5 WITH WIDTH > 0.600
d = INT MSMG5_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MSMG5_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MSMG5 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5011{
@ RULE_MSMG5011
@ Allowed enclosures of VSMG4 by MSMG5
RECTANGLE ENCLOSURE VSMG4 MSMG5 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.028 0.002 0.028 0.002
GOOD 0.032 0 0.032 0
GOOD 0.010 0.010 0.010 0.010
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MSMG5012{
//@ RULE_MSMG5012
//@ VSMG4 center must be aligned to wire center (between 2 longest edges)
//VSMG4_MSMG5_OVERLAP =  VSMG4 AND MSMG5
//// deriving metal and via edge pairs
//MSMG5_edges = INT MSMG5 < 1
//VSMG4_edges = INT VSMG4 < 1
//// deriving metal and via center lines
//MSMG5_centerline = DFM COPY MSMG5_edges CENTERLINE
//VSMG4_centerline = DFM COPY VSMG4_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MSMG5_centerline COIN EDGE VSMG4_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VSMG4_MSMG5_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5013{
@ RULE_MSMG5013
@ VSMG4 shape must be rectangular if enclosing MSMG5 wire width >= 120nm
wide_MSMG5 = MSMG5 WITH WIDTH >= 0.120
VSMG4_in_wideMSMG5 = VSMG4 INSIDE wide_MSMG5
NOT RECTANGLE VSMG4_in_wideMSMG5
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5014{
@ RULE_MSMG5014
@ MSMG5 minimum area for rectangular shape is 0.0024um2
rect_MSMG5 = RECTANGLE MSMG5
AREA rect_MSMG5 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MSMG5015{
@ RULE_MSMG5015
@ MSMG5 min area for non-rectangular shape is 0.0036um2
no_rect_MSMG5 = NOT RECTANGLE MSMG5
AREA no_rect_MSMG5 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________   VG1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_VG1001a{
@ RULE_VG1001a
@ VG1 is a square with 112nm edge length
RECTANGLE VG1 != 0.112 BY != 0.112 ASPECT ==1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VG1001b{
@ RULE_VG1001b
@ VG1 is a rectangle 112nm x 224nm when enclosed in MG1 with width >= 240nm
wide_MG1 = MG1 WITH WIDTH >= 0.240
VG1_wide_MG1 = VG1 INSIDE wide_MG1
RECTANGLE VG1_wide_MG1 != 0.112 BY != 0.224
}
///////////////////////////////////////////////////////////////////////////////////
RULE_VG1001c{
@ RULE_VG1001c
@ VG1 is a rectangle 112nm x 224nm when enclosed in MG2 with width >= 240nm
wide_MG2 = MG2 WITH WIDTH >= 0.240
VG1_wide_MG2 = VG1 INSIDE wide_MG2
RECTANGLE VG1_wide_MG2 != 0.112 BY != 0.224
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VG1002{
 @ RULE_VG1002
 @ Minimum spacing of VG1 if runlength exactly = 112nm is 144nm
 MG1_MG2 = MG1 AND MG2
 // deriving edges of the intersection
 MG1_MG2_EDGES = ANGLE MG1_MG2 == 90
 // identifying edges with runlength = 112nm
 MG1_MG2_EDGES_LENGTH = PATH LENGTH MG1_MG2_EDGES == 0.112
 // forming polygons out of those edges
 MG1_MG2_polygons = MG1 WITH EDGE MG1_MG2_EDGES_LENGTH
 // finding VG1 that interact with the formed polygons
 VG1_MG1_MG2 = VG1 INTERACT MG1_MG2_polygons
 // Finding spacing
 EXT VG1_MG1_MG2 < 0.144
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VG1003{
 @ RULE_VG1003
 @ Minimum spacing of VG1 if runlength < 112nm is 200nm
 // assuming runlength is the common length between MG1 and MG2
 MG1_MG2 = MG1 AND MG2
 // deriving edges of the intersection
 MG1_MG2_EDGES = ANGLE MG1_MG2 == 90
 // identifying edges with runlength < 112nm
 MG1_MG2_EDGES_LENGTH = PATH LENGTH MG1_MG2_EDGES < 0.112
 // forming polygons out of those edges
 MG1_MG2_polygons = MG1 WITH EDGE MG1_MG2_EDGES_LENGTH
 // finding VG1 that interact with the formed polygons
 VG1_MG1_MG2 = VG1 INTERACT MG1_MG2_polygons
 // Finding spacing
 EXT VG1_MG1_MG2 < 0.200
}
////////////////////////////////////////////////////////////////////////////////////
RULE_VG1004{
@ RULE_VG1004
@ VG1 must be inside (MG1 and MG2)
layer_intersections = MG1 AND MG2 
VG1 OUTSIDE layer_intersections
}
//////////////////////////////////////////////////////////////////////////////////
RULE_VG1005{
@ RULE_VG1005
@ VG1 shape must be rectangular if enclosing MG1 wire width >= 240nm
wide_MG1 = MG1 WITH WIDTH >= 0.240
VG1_in_wideMG1 = VG1 INSIDE wide_MG1
NOT RECTANGLE VG1_in_wideMG1
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________   MG1 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MG1001{
@ RULE_MG1001
@ MG1 width > 112nm
INTERNAL MG1 < 0.112
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1002{
@ RULE_MG1002
@ One of two edges connected to the same vertex must have at least one of 224nm
x = CONVEX EDGE MG1 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.224
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1003{
@ RULE_MG1003
@ maximum length of MG1 for wires with min width 112nm is 3.84um
wide_MG1 = MG1 with width >= 0.112
d = INT wide_MG1 <= 1 opposite
d_p = dfm property wide_MG1 d overlap abut also [EC1 = EC(d)] > 3.840
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1004{
@ RULE_MG1004
@ MG1 end-of-line spacing (end-of-line edge defined as edge < 128nm) is 272nm
MG1_eol = LENGTH MG1 < 0.128
EXT MG1_eol < 0.272
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1005{
@ RULE_MG1005
@ MG1 min space and notch 112nm
EXT MG1 < 0.112 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MG1006{
@ RULE_MG1006
@ Minimum spacing of MG1 when MG1 is wider than 120nm and longer than 1200nm is 120nm
MG1_wide = MG1 WITH WIDTH > 0.120
d = INT MG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MG1 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG1007{
@ RULE_MG1007
@ Minimum spacing of MG1 when MG1 is wider than 240nm and longer than 1800nm is 240nm
MG1_wide = MG1 WITH WIDTH > 0.240
d = INT MG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MG1 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG1008{
@ RULE_MG1008
@ Minimum spacing of MG1 when MG1 is wider than 320nm and longer than 2400nm is 320nm
MG1_wide = MG1 WITH WIDTH > 0.320
d = INT MG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MG1 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG1009{
@ RULE_MG1009
@ Minimum spacing of MG1 when MG1 is wider than 600nm and longer than 2400nm is 600nm
MG1_wide = MG1 WITH WIDTH > 0.600
d = INT MG1_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG1_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MG1 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG1010{
@ RULE_MG1010
@ Allowed enclosures of VSMG5 by MG1
RECTANGLE ENCLOSURE VSMG5 MG1 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.0 0.0 0.0 0.0
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MG1011{
//@ RULE_MG1011
//@ VSMG5 center must be aligned to wire center (between 2 longest edges)
//VSMG5_MG1_OVERLAP =  VSMG5 AND MG1
//// deriving metal and via edge pairs
//MG1_edges = INT MG1 < 1
//VSMG5_edges = INT VSMG5 < 1
//// deriving metal and via center lines
//MG1_centerline = DFM COPY MG1_edges CENTERLINE
//VSMG5_centerline = DFM COPY VSMG5_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MG1_centerline COIN EDGE VSMG5_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VSMG5_MG1_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1012{
@ RULE_MG1012
@ VSMG5 shape must be rectangular if enclosing MG1 wire width >= 240nm
wide_MG1 = MG1 WITH WIDTH >= 0.240
VSMG5_in_wideMG1 = VSMG5 INSIDE wide_MG1
NOT RECTANGLE VSMG5_in_wideMG1
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG1013{
@ RULE_MG1013
@ MG1 minimum area for rectangular shape is 0.0024um2
rect_MG1 = RECTANGLE MG1
AREA rect_MG1 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MG1014{
@ RULE_MG1014
@ MG1 min area for non-rectangular shape is 0.0036um2
no_rect_MG1 = NOT RECTANGLE MG1
AREA no_rect_MG1 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//_____________________________________________________________________   MG2 LAYER
////////////////////////////////////////////////////////////////////////////////////
RULE_MG2001{
@ RULE_MG2001
@ MG2 width > 112nm
INTERNAL MG2 < 0.112
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2002{
@ RULE_MG2002
@ One of two edges connected to the same vertex must have at least one of 224nm
x = CONVEX EDGE MG2 ANGLE1==90 ANGLE2==90 WITH LENGTH < 0.224
INT x < 0.001 ABUT 
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2003{
@ RULE_MG2003
@ maximum length of MG2 for wires with min width 112nm is 3.84um
wide_MG2 = MG2 with width >= 0.112
d = INT wide_MG2 <= 1 opposite
d_p = dfm property wide_MG2 d overlap abut also [EC1 = EC(d)] > 3.840
copy d_p
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2004{
@ RULE_MG2004
@ MG2 end-of-line spacing (end-of-line edge defined as edge < 128nm) is 272nm
MG2_eol = LENGTH MG2 < 0.128
EXT MG2_eol < 0.272
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2005{
@ RULE_MG2005
@ MG2 min space and notch 112nm
EXT MG2 < 0.112 NOTCH
}
//////////////////////////////////////////////////////////////////////////////////
RULE_MG2006{
@ RULE_MG2006
@ Minimum spacing of MG2 when MG2 is wider than 120nm and longer than 1200nm is 120nm
MG2_wide = MG2 WITH WIDTH > 0.120
d = INT MG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.200
EXT d_p MG2 <= 0.120
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG2007{
@ RULE_MG2007
@ Minimum spacing of MG2 when MG2 is wider than 240nm and longer than 1800nm is 240nm
MG2_wide = MG2 WITH WIDTH > 0.240
d = INT MG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 1.800
EXT d_p MG2 <= 0.240
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG2008{
@ RULE_MG2008
@ Minimum spacing of MG2 when MG2 is wider than 320nm and longer than 2400nm is 320nm
MG2_wide = MG2 WITH WIDTH > 0.320
d = INT MG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MG2 <= 0.320
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG2009{
@ RULE_MG2009
@ Minimum spacing of MG2 when MG2 is wider than 600nm and longer than 2400nm is 600nm
MG2_wide = MG2 WITH WIDTH > 0.600
d = INT MG2_wide <= 1 OPPOSITE
d_p = DFM PROPERTY MG2_wide d OVERLAP ABUT ALSO [EC1 = EC(d)] > 2.400
EXT d_p MG2 <= 0.600
}
/////////////////////////////////////////////////////////////////////////////////
RULE_MG2010{
@ RULE_MG2010
@ Allowed enclosures of VG1 by MG2
RECTANGLE ENCLOSURE VG1 MG2 ABUT>0<90 SINGULAR ORTHOGONAL ONLY
GOOD 0.0 0.0 0.0 0.0
}
/////////////////////////////////////////////////////////////////////////////////
//RULE_MG2011{
//@ RULE_MG2011
//@ VG1 center must be aligned to wire center (between 2 longest edges)
//VG1_MG2_OVERLAP =  VG1 AND MG2
//// deriving metal and via edge pairs
//MG2_edges = INT MG2 < 1
//VG1_edges = INT VG1 < 1
//// deriving metal and via center lines
//MG2_centerline = DFM COPY MG2_edges CENTERLINE
//VG1_centerline = DFM COPY VG1_edges CENTERLINE
//// identifying vias aligned on metal centers (coinciding center lines)
//coin_centerlines = MG2_centerline COIN EDGE VG1_centerline
//// creating thin polygons out of the coinciding centerlines
//x = EXPAND EDGE coin_centerlines INSIDE BY 0.01
//y = copy x
//// output vias that do not interact with the formed polygons
//VG1_MG2_OVERLAP NOT INTERACT y
//}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2012{
@ RULE_MG2012
@ VG1 shape must be rectangular if enclosing MG2 wire width >= 240nm
wide_MG2 = MG2 WITH WIDTH >= 0.240
VG1_in_wideMG2 = VG1 INSIDE wide_MG2
NOT RECTANGLE VG1_in_wideMG2
}
///////////////////////////////////////////////////////////////////////////////////
RULE_MG2013{
@ RULE_MG2013
@ MG2 minimum area for rectangular shape is 0.0024um2
rect_MG2 = RECTANGLE MG2
AREA rect_MG2 < 0.0024
}
////////////////////////////////////////////////////////////////////////////////
RULE_MG2014{
@ RULE_MG2014
@ MG2 min area for non-rectangular shape is 0.0036um2
no_rect_MG2 = NOT RECTANGLE MG2
AREA no_rect_MG2 < 0.0036
}
////////////////////////////////////////////////////////////////////////////////////
//______________________________________________________________________ Other Rules
////////////////////////////////////////////////////////////////////////////////////
RULE_MIS01{
 @ RULE_MIS01
 @ Shapes on all layers must be on a 0.5 nm grid
 // PRECISION			1000
 // RESOLUTION			500
 DRAWN OFFGRID
}
////////////////////////////////////////////////////////////////////////////////////

RULE_MIS02A{
 @ RULE_MIS02A
 @ [ANTENNA] Ratio of Maximum Allowed GATE[A] Area to transistor Gate Area is 100:1
 // 1 - Assume Proper layer derivations
 // 2 - Establish zones connectivities
 // 3 - Apply NET AREA RATIO Constraine
 NET AREA RATIO GATEA GIL M1A MINT1A MINT2A MINT3A MINT4A MINT5A OVER N_GATE_A P_GATE_A > 100
}
////////////////////////////////////////////////////////////////////////////////////

RULE_MIS02B{
 @ RULE_MIS02B
 @ [ANTENNA] Ratio of Maximum Allowed GATE[B] Area to transistor Gate Area is 100:1
 // 1 - Assume Proper layer derivations
 
 // 2 - Establish zones connectivities

 // 3 - Apply NET AREA RATIO Constraine
 NET AREA RATIO GATEB GIL M1B MINT1B MINT2B MINT3B MINT4B MINT5B OVER N_GATE_B P_GATE_B > 100
}
////////////////////////////////////////////////////////////////////////////////////
//______________________________________________________________________ END OF FILE
////////////////////////////////////////////////////////////////////////////////////
